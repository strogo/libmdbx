<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libmdbx: mdbx::slice Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libmdbx
   &#160;<span id="projectnumber">0.9.1.4 (2020-10-01T02:28:10+03:00)</span>
   </div>
   <div id="projectbrief">One of the fastest compact embeddable key-value ACID database without WAL.</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('structmdbx_1_1slice.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">mdbx::slice Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>References a data located outside the slice.  
 <a href="structmdbx_1_1slice.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="mdbx_8h_09_09_source.html">mdbx.h++</a>&gt;</code></p>

<p>Inherits MDBX_val.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3c416cc79e62785145d10a7ac4dbfc91"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="structmdbx_1_1slice.html#a3c416cc79e62785145d10a7ac4dbfc91a2d53525f1ae978c25b11c334cb0c20c0">max_length</a> = MDBX_MAXDATASIZE
 }</td></tr>
<tr class="separator:a3c416cc79e62785145d10a7ac4dbfc91"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3ae8bc090ddbf0840e7403caa4c1340e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__api__macros.html#ga4912ff2f7d4f6a15b96c54e5cf8ee0f5">MDBX_CXX11_CONSTEXPR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a3ae8bc090ddbf0840e7403caa4c1340e">slice</a> () noexcept</td></tr>
<tr class="memdesc:a3ae8bc090ddbf0840e7403caa4c1340e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an empty slice.  <a href="structmdbx_1_1slice.html#a3ae8bc090ddbf0840e7403caa4c1340e">More...</a><br /></td></tr>
<tr class="separator:a3ae8bc090ddbf0840e7403caa4c1340e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad49be025821f597622feeb197080a5e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__api__macros.html#gad12bcc78029f8edc91982e1bac29eeb9">MDBX_CXX14_CONSTEXPR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#ad49be025821f597622feeb197080a5e7">slice</a> (const void *ptr, size_t bytes)</td></tr>
<tr class="memdesc:ad49be025821f597622feeb197080a5e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a slice that refers to [0,bytes-1] of memory bytes pointed by ptr.  <a href="structmdbx_1_1slice.html#ad49be025821f597622feeb197080a5e7">More...</a><br /></td></tr>
<tr class="separator:ad49be025821f597622feeb197080a5e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89bfac035eab040a04c60396473d4395"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__api__macros.html#gad12bcc78029f8edc91982e1bac29eeb9">MDBX_CXX14_CONSTEXPR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a89bfac035eab040a04c60396473d4395">slice</a> (const void *begin, const void *end)</td></tr>
<tr class="memdesc:a89bfac035eab040a04c60396473d4395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a slice that refers to [begin,end] of memory bytes.  <a href="structmdbx_1_1slice.html#a89bfac035eab040a04c60396473d4395">More...</a><br /></td></tr>
<tr class="separator:a89bfac035eab040a04c60396473d4395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e488667b0dee1cdcee2fe9efa50c22"><td class="memTemplParams" colspan="2">template&lt;size_t SIZE&gt; </td></tr>
<tr class="memitem:aa4e488667b0dee1cdcee2fe9efa50c22"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__api__macros.html#gad12bcc78029f8edc91982e1bac29eeb9">MDBX_CXX14_CONSTEXPR</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#aa4e488667b0dee1cdcee2fe9efa50c22">slice</a> (const char(&amp;text)[SIZE]) noexcept</td></tr>
<tr class="memdesc:aa4e488667b0dee1cdcee2fe9efa50c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a slice that refers to text[0,strlen(text)-1].  <a href="structmdbx_1_1slice.html#aa4e488667b0dee1cdcee2fe9efa50c22">More...</a><br /></td></tr>
<tr class="separator:aa4e488667b0dee1cdcee2fe9efa50c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770a0604402b734d0df2d1fce7fec2c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="mdbx_8h_09_09.html#ac481c8c5dbfd2f48685ea99bcbc4c5e0">MDBX_CXX17_CONSTEXPR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a770a0604402b734d0df2d1fce7fec2c5">slice</a> (const char *c_str)</td></tr>
<tr class="memdesc:a770a0604402b734d0df2d1fce7fec2c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a slice that refers to c_str[0,strlen(c_str)-1].  <a href="structmdbx_1_1slice.html#a770a0604402b734d0df2d1fce7fec2c5">More...</a><br /></td></tr>
<tr class="separator:a770a0604402b734d0df2d1fce7fec2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a52b59efcfde3319c0a7ea6244fe51"><td class="memTemplParams" colspan="2">template&lt;class C , class T , class A &gt; </td></tr>
<tr class="memitem:a98a52b59efcfde3319c0a7ea6244fe51"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="mdbx_8h_09_09.html#a006b5a41dcea1c018efaa0b36fb94cc5">MDBX_CXX20_CONSTEXPR</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a98a52b59efcfde3319c0a7ea6244fe51">slice</a> (const ::std::basic_string&lt; C, T, A &gt; &amp;str)</td></tr>
<tr class="memdesc:a98a52b59efcfde3319c0a7ea6244fe51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a slice that refers to the contents of "str".  <a href="structmdbx_1_1slice.html#a98a52b59efcfde3319c0a7ea6244fe51">More...</a><br /></td></tr>
<tr class="separator:a98a52b59efcfde3319c0a7ea6244fe51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c6d4f4718fa2251dc3980e19e3973c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__api__macros.html#gad12bcc78029f8edc91982e1bac29eeb9">MDBX_CXX14_CONSTEXPR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#af8c6d4f4718fa2251dc3980e19e3973c">slice</a> (const <a class="el" href="group__c__api.html#ga5eedfc4a83296bbf0f8ff93359cb0900">MDBX_val</a> &amp;src)</td></tr>
<tr class="separator:af8c6d4f4718fa2251dc3980e19e3973c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd3d8e8cc1e7676767cb14b657facb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__api__macros.html#ga4912ff2f7d4f6a15b96c54e5cf8ee0f5">MDBX_CXX11_CONSTEXPR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a1bd3d8e8cc1e7676767cb14b657facb9">slice</a> (const <a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;) noexcept=default</td></tr>
<tr class="separator:a1bd3d8e8cc1e7676767cb14b657facb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6358af305d1dffdbfa5e2851ccb30a1"><td class="memTemplParams" colspan="2">template&lt;class C , class T &gt; </td></tr>
<tr class="memitem:ac6358af305d1dffdbfa5e2851ccb30a1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__api__macros.html#gad12bcc78029f8edc91982e1bac29eeb9">MDBX_CXX14_CONSTEXPR</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#ac6358af305d1dffdbfa5e2851ccb30a1">slice</a> (const ::std::basic_string_view&lt; C, T &gt; &amp;sv)</td></tr>
<tr class="memdesc:ac6358af305d1dffdbfa5e2851ccb30a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a slice that refers to the same contents as "sv".  <a href="structmdbx_1_1slice.html#ac6358af305d1dffdbfa5e2851ccb30a1">More...</a><br /></td></tr>
<tr class="separator:ac6358af305d1dffdbfa5e2851ccb30a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4cb9f5defb50c0bc85a5961c4979391"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#ab4cb9f5defb50c0bc85a5961c4979391">slice</a> (<a class="el" href="group__c__api.html#ga5eedfc4a83296bbf0f8ff93359cb0900">MDBX_val</a> &amp;&amp;src)</td></tr>
<tr class="separator:ab4cb9f5defb50c0bc85a5961c4979391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad2b4b4181c6e71f9e298172e718ebe7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#aad2b4b4181c6e71f9e298172e718ebe7">slice</a> (<a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;&amp;src) noexcept</td></tr>
<tr class="separator:aad2b4b4181c6e71f9e298172e718ebe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e55976f373982c3316f53eef0cc87fa"><td class="memTemplParams" colspan="2">template&lt;class C , class T &gt; </td></tr>
<tr class="memitem:a8e55976f373982c3316f53eef0cc87fa"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a8e55976f373982c3316f53eef0cc87fa">slice</a> (::std::basic_string_view&lt; C, T &gt; &amp;&amp;sv)</td></tr>
<tr class="separator:a8e55976f373982c3316f53eef0cc87fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cac4c0dba09131704fc13e23e7caee8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a1cac4c0dba09131704fc13e23e7caee8">assign</a> (const void *ptr, size_t bytes)</td></tr>
<tr class="separator:a1cac4c0dba09131704fc13e23e7caee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b0854d1b1004d154fcb7a3ed111957"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#af6b0854d1b1004d154fcb7a3ed111957">assign</a> (const <a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;src) noexcept</td></tr>
<tr class="separator:af6b0854d1b1004d154fcb7a3ed111957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39cd2a1bf72b7eb2f45fc066368be24e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a39cd2a1bf72b7eb2f45fc066368be24e">assign</a> (const ::<a class="el" href="group__c__api.html#ga5eedfc4a83296bbf0f8ff93359cb0900">MDBX_val</a> &amp;src)</td></tr>
<tr class="separator:a39cd2a1bf72b7eb2f45fc066368be24e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb10fb6c7885ffdb5668b1472ce4c61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a2bb10fb6c7885ffdb5668b1472ce4c61">assign</a> (<a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;&amp;src) noexcept</td></tr>
<tr class="separator:a2bb10fb6c7885ffdb5668b1472ce4c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5993b2fba342e7334a3b1867fc8f9e26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a5993b2fba342e7334a3b1867fc8f9e26">assign</a> (::<a class="el" href="group__c__api.html#ga5eedfc4a83296bbf0f8ff93359cb0900">MDBX_val</a> &amp;&amp;src)</td></tr>
<tr class="separator:a5993b2fba342e7334a3b1867fc8f9e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c2a277b73fb6d72597249fe8c826ae1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a5c2a277b73fb6d72597249fe8c826ae1">assign</a> (const void *begin, const void *end)</td></tr>
<tr class="separator:a5c2a277b73fb6d72597249fe8c826ae1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac114cb2638e97a3d60fef3124d4ee4cf"><td class="memTemplParams" colspan="2">template&lt;class C , class T , class A &gt; </td></tr>
<tr class="memitem:ac114cb2638e97a3d60fef3124d4ee4cf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#ac114cb2638e97a3d60fef3124d4ee4cf">assign</a> (const ::std::basic_string&lt; C, T, A &gt; &amp;str)</td></tr>
<tr class="separator:ac114cb2638e97a3d60fef3124d4ee4cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb454a827ec3cfe8a7fe778bbfed301d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#abb454a827ec3cfe8a7fe778bbfed301d">assign</a> (const char *c_str)</td></tr>
<tr class="separator:abb454a827ec3cfe8a7fe778bbfed301d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15034a2f9fb9826615d1ef8f81ecadb"><td class="memTemplParams" colspan="2">template&lt;class C , class T &gt; </td></tr>
<tr class="memitem:ab15034a2f9fb9826615d1ef8f81ecadb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#ab15034a2f9fb9826615d1ef8f81ecadb">assign</a> (const ::std::basic_string_view&lt; C, T &gt; &amp;view)</td></tr>
<tr class="separator:ab15034a2f9fb9826615d1ef8f81ecadb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f00aa7e03405e8bfce4ecab87dd39b6"><td class="memTemplParams" colspan="2">template&lt;class C , class T &gt; </td></tr>
<tr class="memitem:a2f00aa7e03405e8bfce4ecab87dd39b6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a2f00aa7e03405e8bfce4ecab87dd39b6">assign</a> (::std::basic_string_view&lt; C, T &gt; &amp;&amp;view)</td></tr>
<tr class="separator:a2f00aa7e03405e8bfce4ecab87dd39b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7681c3ef3e4874dff08d4be4239e226e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a7681c3ef3e4874dff08d4be4239e226e">operator=</a> (const <a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;) noexcept=default</td></tr>
<tr class="separator:a7681c3ef3e4874dff08d4be4239e226e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a81234bece30a8a472f7ca0ef4ebc88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a5a81234bece30a8a472f7ca0ef4ebc88">operator=</a> (<a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;&amp;src) noexcept</td></tr>
<tr class="separator:a5a81234bece30a8a472f7ca0ef4ebc88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23f41ea724d8878c14f0b407655e46e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a23f41ea724d8878c14f0b407655e46e3">operator=</a> (::<a class="el" href="group__c__api.html#ga5eedfc4a83296bbf0f8ff93359cb0900">MDBX_val</a> &amp;&amp;src)</td></tr>
<tr class="separator:a23f41ea724d8878c14f0b407655e46e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a59dfaa97f712df262357c1c5eef424"><td class="memTemplParams" colspan="2">template&lt;class C , class T &gt; </td></tr>
<tr class="memitem:a8a59dfaa97f712df262357c1c5eef424"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a8a59dfaa97f712df262357c1c5eef424">operator=</a> (const ::std::basic_string_view&lt; C, T &gt; &amp;view)</td></tr>
<tr class="separator:a8a59dfaa97f712df262357c1c5eef424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3efbf9b9bc5394c17cf745b12061e8fc"><td class="memTemplParams" colspan="2">template&lt;class C , class T &gt; </td></tr>
<tr class="memitem:a3efbf9b9bc5394c17cf745b12061e8fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a3efbf9b9bc5394c17cf745b12061e8fc">operator=</a> (::std::basic_string_view&lt; C, T &gt; &amp;&amp;view)</td></tr>
<tr class="separator:a3efbf9b9bc5394c17cf745b12061e8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955e242bd504dd31c7c6a00b76ffebec"><td class="memTemplParams" colspan="2">template&lt;class C  = char, class T  = ::std::char_traits&lt;C&gt;, class A  = legacy_allocator&gt; </td></tr>
<tr class="memitem:a955e242bd504dd31c7c6a00b76ffebec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="mdbx_8h_09_09.html#a006b5a41dcea1c018efaa0b36fb94cc5">MDBX_CXX20_CONSTEXPR</a> ::std::basic_string&lt; C, T, A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a955e242bd504dd31c7c6a00b76ffebec">string</a> (const A &amp;allocator=A()) const</td></tr>
<tr class="separator:a955e242bd504dd31c7c6a00b76ffebec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8429d3d98004f500851f0a5f51559b2b"><td class="memTemplParams" colspan="2">template&lt;class C , class T , class A &gt; </td></tr>
<tr class="memitem:a8429d3d98004f500851f0a5f51559b2b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="mdbx_8h_09_09.html#a006b5a41dcea1c018efaa0b36fb94cc5">MDBX_CXX20_CONSTEXPR</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a8429d3d98004f500851f0a5f51559b2b">operator::std::basic_string</a> () const</td></tr>
<tr class="separator:a8429d3d98004f500851f0a5f51559b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a575904c24d83e8f4b3c49ed17330bcce"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a575904c24d83e8f4b3c49ed17330bcce">to_hex</a> (char *dest, size_t dest_size, <a class="el" href="group__api__macros.html#gabb452686968e48b67397da5f97445f5b">bool</a> uppercase=<a class="el" href="group__api__macros.html#ga65e9886d74aaee76545e83dd09011727">false</a>, unsigned wrap_width=0) const</td></tr>
<tr class="memdesc:a575904c24d83e8f4b3c49ed17330bcce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the buffer by hexadecimal data dump of slice content.  <a href="structmdbx_1_1slice.html#a575904c24d83e8f4b3c49ed17330bcce">More...</a><br /></td></tr>
<tr class="separator:a575904c24d83e8f4b3c49ed17330bcce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f04bb7b2fb39854fa785c5b5eb6b415"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__api__macros.html#ga4912ff2f7d4f6a15b96c54e5cf8ee0f5">MDBX_CXX11_CONSTEXPR</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a5f04bb7b2fb39854fa785c5b5eb6b415">to_hex_bytes</a> (unsigned wrap_width=0) const noexcept</td></tr>
<tr class="memdesc:a5f04bb7b2fb39854fa785c5b5eb6b415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the buffer size in bytes needed for hexadecimal data dump of slice content.  <a href="structmdbx_1_1slice.html#a5f04bb7b2fb39854fa785c5b5eb6b415">More...</a><br /></td></tr>
<tr class="separator:a5f04bb7b2fb39854fa785c5b5eb6b415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ecb1a4f1c20321d8a197362915b3850"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemdbx.html#acf30affbf4d2cbbaf4e41effd5196306">byte</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a1ecb1a4f1c20321d8a197362915b3850">from_hex</a> (<a class="el" href="namespacemdbx.html#acf30affbf4d2cbbaf4e41effd5196306">byte</a> *dest, size_t dest_size, <a class="el" href="group__api__macros.html#gabb452686968e48b67397da5f97445f5b">bool</a> ignore_spaces=<a class="el" href="group__api__macros.html#ga65e9886d74aaee76545e83dd09011727">false</a>) const</td></tr>
<tr class="memdesc:a1ecb1a4f1c20321d8a197362915b3850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the buffer with data converted from hexadecimal dump from slice content.  <a href="structmdbx_1_1slice.html#a1ecb1a4f1c20321d8a197362915b3850">More...</a><br /></td></tr>
<tr class="separator:a1ecb1a4f1c20321d8a197362915b3850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7766acc920d26c1c7ba74be42b89c327"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__api__macros.html#ga4912ff2f7d4f6a15b96c54e5cf8ee0f5">MDBX_CXX11_CONSTEXPR</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a7766acc920d26c1c7ba74be42b89c327">from_hex_bytes</a> () const noexcept</td></tr>
<tr class="memdesc:a7766acc920d26c1c7ba74be42b89c327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the buffer size in bytes needed for conversion hexadecimal dump from slice content to data.  <a href="structmdbx_1_1slice.html#a7766acc920d26c1c7ba74be42b89c327">More...</a><br /></td></tr>
<tr class="separator:a7766acc920d26c1c7ba74be42b89c327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad391e8c064914c01a0da51db61c3a131"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#ad391e8c064914c01a0da51db61c3a131">to_base58</a> (char *dest, size_t dest_size, unsigned wrap_width=0) const</td></tr>
<tr class="memdesc:ad391e8c064914c01a0da51db61c3a131"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the buffer by <a href="https://en.wikipedia.org/wiki/Base58">Base58</a> data dump of slice content.  <a href="structmdbx_1_1slice.html#ad391e8c064914c01a0da51db61c3a131">More...</a><br /></td></tr>
<tr class="separator:ad391e8c064914c01a0da51db61c3a131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a655678563a631f584727ea0a594f8a7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__api__macros.html#ga4912ff2f7d4f6a15b96c54e5cf8ee0f5">MDBX_CXX11_CONSTEXPR</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a655678563a631f584727ea0a594f8a7c">to_base58_bytes</a> (unsigned wrap_width=0) const noexcept</td></tr>
<tr class="memdesc:a655678563a631f584727ea0a594f8a7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the buffer size in bytes needed for <a href="https://en.wikipedia.org/wiki/Base58">Base58</a> data dump of slice content.  <a href="structmdbx_1_1slice.html#a655678563a631f584727ea0a594f8a7c">More...</a><br /></td></tr>
<tr class="separator:a655678563a631f584727ea0a594f8a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ddadf607eb189ed0d8644c848ecdb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemdbx.html#acf30affbf4d2cbbaf4e41effd5196306">byte</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a28ddadf607eb189ed0d8644c848ecdb6">from_base58</a> (<a class="el" href="namespacemdbx.html#acf30affbf4d2cbbaf4e41effd5196306">byte</a> *dest, size_t dest_size, <a class="el" href="group__api__macros.html#gabb452686968e48b67397da5f97445f5b">bool</a> ignore_spaces=<a class="el" href="group__api__macros.html#ga65e9886d74aaee76545e83dd09011727">false</a>) const</td></tr>
<tr class="memdesc:a28ddadf607eb189ed0d8644c848ecdb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the buffer with data converted from <a href="https://en.wikipedia.org/wiki/Base58">Base58</a> dump from slice content.  <a href="structmdbx_1_1slice.html#a28ddadf607eb189ed0d8644c848ecdb6">More...</a><br /></td></tr>
<tr class="separator:a28ddadf607eb189ed0d8644c848ecdb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a998c93cadb9df0284f0babb758cd9870"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__api__macros.html#ga4912ff2f7d4f6a15b96c54e5cf8ee0f5">MDBX_CXX11_CONSTEXPR</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a998c93cadb9df0284f0babb758cd9870">from_base58_bytes</a> () const noexcept</td></tr>
<tr class="memdesc:a998c93cadb9df0284f0babb758cd9870"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the buffer size in bytes needed for conversion <a href="https://en.wikipedia.org/wiki/Base58">Base58</a> dump to data.  <a href="structmdbx_1_1slice.html#a998c93cadb9df0284f0babb758cd9870">More...</a><br /></td></tr>
<tr class="separator:a998c93cadb9df0284f0babb758cd9870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616911ad40a1ed299e75b292ab909419"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a616911ad40a1ed299e75b292ab909419">to_base64</a> (char *dest, size_t dest_size, unsigned wrap_width=0) const</td></tr>
<tr class="memdesc:a616911ad40a1ed299e75b292ab909419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the buffer by <a href="https://en.wikipedia.org/wiki/Base64">Base64</a> data dump.  <a href="structmdbx_1_1slice.html#a616911ad40a1ed299e75b292ab909419">More...</a><br /></td></tr>
<tr class="separator:a616911ad40a1ed299e75b292ab909419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29871ca22d6f38aac998e1294e70540"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__api__macros.html#ga4912ff2f7d4f6a15b96c54e5cf8ee0f5">MDBX_CXX11_CONSTEXPR</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#ac29871ca22d6f38aac998e1294e70540">to_base64_bytes</a> (unsigned wrap_width=0) const noexcept</td></tr>
<tr class="memdesc:ac29871ca22d6f38aac998e1294e70540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the buffer size in bytes needed for <a href="https://en.wikipedia.org/wiki/Base64">Base64</a> data dump.  <a href="structmdbx_1_1slice.html#ac29871ca22d6f38aac998e1294e70540">More...</a><br /></td></tr>
<tr class="separator:ac29871ca22d6f38aac998e1294e70540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63aa61531dc882114c273fe30b83ea3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemdbx.html#acf30affbf4d2cbbaf4e41effd5196306">byte</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a63aa61531dc882114c273fe30b83ea3d">from_base64</a> (<a class="el" href="namespacemdbx.html#acf30affbf4d2cbbaf4e41effd5196306">byte</a> *dest, size_t dest_size, <a class="el" href="group__api__macros.html#gabb452686968e48b67397da5f97445f5b">bool</a> ignore_spaces=<a class="el" href="group__api__macros.html#ga65e9886d74aaee76545e83dd09011727">false</a>) const</td></tr>
<tr class="memdesc:a63aa61531dc882114c273fe30b83ea3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the buffer with data converted from <a href="https://en.wikipedia.org/wiki/Base64">Base64</a> dump.  <a href="structmdbx_1_1slice.html#a63aa61531dc882114c273fe30b83ea3d">More...</a><br /></td></tr>
<tr class="separator:a63aa61531dc882114c273fe30b83ea3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b36f3a8f752b979152c13621d02602"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__api__macros.html#ga4912ff2f7d4f6a15b96c54e5cf8ee0f5">MDBX_CXX11_CONSTEXPR</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#ac2b36f3a8f752b979152c13621d02602">from_base64_bytes</a> () const noexcept</td></tr>
<tr class="memdesc:ac2b36f3a8f752b979152c13621d02602"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the buffer size in bytes needed for conversion <a href="https://en.wikipedia.org/wiki/Base64">Base64</a> dump to data.  <a href="structmdbx_1_1slice.html#ac2b36f3a8f752b979152c13621d02602">More...</a><br /></td></tr>
<tr class="separator:ac2b36f3a8f752b979152c13621d02602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad647165fd9eed56bf574bcc592fe3355"><td class="memTemplParams" colspan="2">template&lt;class ALLOCATOR  = legacy_allocator&gt; </td></tr>
<tr class="memitem:ad647165fd9eed56bf574bcc592fe3355"><td class="memTemplItemLeft" align="right" valign="top">inline ::<a class="el" href="namespacemdbx.html#a8dd1a3685fba824adcf008ce1e91c8f9">mdbx::string</a>&lt; ALLOCATOR &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#ad647165fd9eed56bf574bcc592fe3355">hex_encode</a> (<a class="el" href="group__api__macros.html#gabb452686968e48b67397da5f97445f5b">bool</a> uppercase=<a class="el" href="group__api__macros.html#ga65e9886d74aaee76545e83dd09011727">false</a>, const ALLOCATOR &amp;allocator=ALLOCATOR()) const</td></tr>
<tr class="memdesc:ad647165fd9eed56bf574bcc592fe3355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string with a hexadecimal dump of the slice content.  <a href="structmdbx_1_1slice.html#ad647165fd9eed56bf574bcc592fe3355">More...</a><br /></td></tr>
<tr class="separator:ad647165fd9eed56bf574bcc592fe3355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cce5923f0ef49dd4d7b6b6e45c8a6d6"><td class="memTemplParams" colspan="2">template&lt;class ALLOCATOR  = legacy_allocator&gt; </td></tr>
<tr class="memitem:a2cce5923f0ef49dd4d7b6b6e45c8a6d6"><td class="memTemplItemLeft" align="right" valign="top">inline ::<a class="el" href="namespacemdbx.html#a8dd1a3685fba824adcf008ce1e91c8f9">mdbx::string</a>&lt; ALLOCATOR &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a2cce5923f0ef49dd4d7b6b6e45c8a6d6">hex_decode</a> (const ALLOCATOR &amp;allocator=ALLOCATOR()) const</td></tr>
<tr class="memdesc:a2cce5923f0ef49dd4d7b6b6e45c8a6d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes hexadecimal dump from the slice content into returned data string.  <a href="structmdbx_1_1slice.html#a2cce5923f0ef49dd4d7b6b6e45c8a6d6">More...</a><br /></td></tr>
<tr class="separator:a2cce5923f0ef49dd4d7b6b6e45c8a6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4fafe5ed4cedea76b5dbbf5cfa26104"><td class="memTemplParams" colspan="2">template&lt;class ALLOCATOR  = legacy_allocator&gt; </td></tr>
<tr class="memitem:aa4fafe5ed4cedea76b5dbbf5cfa26104"><td class="memTemplItemLeft" align="right" valign="top">inline ::<a class="el" href="namespacemdbx.html#a8dd1a3685fba824adcf008ce1e91c8f9">mdbx::string</a>&lt; ALLOCATOR &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#aa4fafe5ed4cedea76b5dbbf5cfa26104">base58_encode</a> (const ALLOCATOR &amp;allocator=ALLOCATOR()) const</td></tr>
<tr class="memdesc:aa4fafe5ed4cedea76b5dbbf5cfa26104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string with a <a href="https://en.wikipedia.org/wiki/Base58">Base58</a> dump of the slice content.  <a href="structmdbx_1_1slice.html#aa4fafe5ed4cedea76b5dbbf5cfa26104">More...</a><br /></td></tr>
<tr class="separator:aa4fafe5ed4cedea76b5dbbf5cfa26104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae159395d655779747d0e381f210e7c39"><td class="memTemplParams" colspan="2">template&lt;class ALLOCATOR  = legacy_allocator&gt; </td></tr>
<tr class="memitem:ae159395d655779747d0e381f210e7c39"><td class="memTemplItemLeft" align="right" valign="top">inline ::<a class="el" href="namespacemdbx.html#a8dd1a3685fba824adcf008ce1e91c8f9">mdbx::string</a>&lt; ALLOCATOR &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#ae159395d655779747d0e381f210e7c39">base58_decode</a> (const ALLOCATOR &amp;allocator=ALLOCATOR()) const</td></tr>
<tr class="memdesc:ae159395d655779747d0e381f210e7c39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes <a href="https://en.wikipedia.org/wiki/Base58">Base58</a> dump from the slice content into returned data string.  <a href="structmdbx_1_1slice.html#ae159395d655779747d0e381f210e7c39">More...</a><br /></td></tr>
<tr class="separator:ae159395d655779747d0e381f210e7c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b80d41eb4d976923af463954ad7d1f"><td class="memTemplParams" colspan="2">template&lt;class ALLOCATOR  = legacy_allocator&gt; </td></tr>
<tr class="memitem:ad1b80d41eb4d976923af463954ad7d1f"><td class="memTemplItemLeft" align="right" valign="top">inline ::<a class="el" href="namespacemdbx.html#a8dd1a3685fba824adcf008ce1e91c8f9">mdbx::string</a>&lt; ALLOCATOR &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#ad1b80d41eb4d976923af463954ad7d1f">base64_encode</a> (const ALLOCATOR &amp;allocator=ALLOCATOR()) const</td></tr>
<tr class="memdesc:ad1b80d41eb4d976923af463954ad7d1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string with a <a href="https://en.wikipedia.org/wiki/Base64">Base64</a> dump of the slice content.  <a href="structmdbx_1_1slice.html#ad1b80d41eb4d976923af463954ad7d1f">More...</a><br /></td></tr>
<tr class="separator:ad1b80d41eb4d976923af463954ad7d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134d5464573d2ee5f1db2fa43b9380a1"><td class="memTemplParams" colspan="2">template&lt;class ALLOCATOR  = legacy_allocator&gt; </td></tr>
<tr class="memitem:a134d5464573d2ee5f1db2fa43b9380a1"><td class="memTemplItemLeft" align="right" valign="top">inline ::<a class="el" href="namespacemdbx.html#a8dd1a3685fba824adcf008ce1e91c8f9">mdbx::string</a>&lt; ALLOCATOR &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a134d5464573d2ee5f1db2fa43b9380a1">base64_decode</a> (const ALLOCATOR &amp;allocator=ALLOCATOR()) const</td></tr>
<tr class="memdesc:a134d5464573d2ee5f1db2fa43b9380a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes <a href="https://en.wikipedia.org/wiki/Base64">Base64</a> dump from the slice content into returned data string.  <a href="structmdbx_1_1slice.html#a134d5464573d2ee5f1db2fa43b9380a1">More...</a><br /></td></tr>
<tr class="separator:a134d5464573d2ee5f1db2fa43b9380a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a329fdd57ba7066275bb289ca5a86afbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__api__macros.html#gad5691bbd85b2cd95f66e527e46b50d3e">MDBX_NOTHROW_PURE_FUNCTION</a> <a class="el" href="group__api__macros.html#gabb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a329fdd57ba7066275bb289ca5a86afbb">is_printable</a> (<a class="el" href="group__api__macros.html#gabb452686968e48b67397da5f97445f5b">bool</a> disable_utf8=<a class="el" href="group__api__macros.html#ga65e9886d74aaee76545e83dd09011727">false</a>) const noexcept</td></tr>
<tr class="memdesc:a329fdd57ba7066275bb289ca5a86afbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the content of the slice is printable.  <a href="structmdbx_1_1slice.html#a329fdd57ba7066275bb289ca5a86afbb">More...</a><br /></td></tr>
<tr class="separator:a329fdd57ba7066275bb289ca5a86afbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6431627b97ee96678994888369091534"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__api__macros.html#gad5691bbd85b2cd95f66e527e46b50d3e">MDBX_NOTHROW_PURE_FUNCTION</a> <a class="el" href="group__api__macros.html#gabb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a6431627b97ee96678994888369091534">is_hex</a> (<a class="el" href="group__api__macros.html#gabb452686968e48b67397da5f97445f5b">bool</a> ignore_spaces=<a class="el" href="group__api__macros.html#ga65e9886d74aaee76545e83dd09011727">false</a>) const noexcept</td></tr>
<tr class="memdesc:a6431627b97ee96678994888369091534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the content of the slice is a hexadecimal dump.  <a href="structmdbx_1_1slice.html#a6431627b97ee96678994888369091534">More...</a><br /></td></tr>
<tr class="separator:a6431627b97ee96678994888369091534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73da4504ae4f1b80e2fcded85ab3e473"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__api__macros.html#gad5691bbd85b2cd95f66e527e46b50d3e">MDBX_NOTHROW_PURE_FUNCTION</a> <a class="el" href="group__api__macros.html#gabb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a73da4504ae4f1b80e2fcded85ab3e473">is_base58</a> (<a class="el" href="group__api__macros.html#gabb452686968e48b67397da5f97445f5b">bool</a> ignore_spaces=<a class="el" href="group__api__macros.html#ga65e9886d74aaee76545e83dd09011727">false</a>) const noexcept</td></tr>
<tr class="memdesc:a73da4504ae4f1b80e2fcded85ab3e473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the content of the slice is a <a href="https://en.wikipedia.org/wiki/Base58">Base58</a> dump.  <a href="structmdbx_1_1slice.html#a73da4504ae4f1b80e2fcded85ab3e473">More...</a><br /></td></tr>
<tr class="separator:a73da4504ae4f1b80e2fcded85ab3e473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a35763f4c526ae3398960a1c2a07dd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__api__macros.html#gad5691bbd85b2cd95f66e527e46b50d3e">MDBX_NOTHROW_PURE_FUNCTION</a> <a class="el" href="group__api__macros.html#gabb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a5a35763f4c526ae3398960a1c2a07dd2">is_base64</a> (<a class="el" href="group__api__macros.html#gabb452686968e48b67397da5f97445f5b">bool</a> ignore_spaces=<a class="el" href="group__api__macros.html#ga65e9886d74aaee76545e83dd09011727">false</a>) const noexcept</td></tr>
<tr class="memdesc:a5a35763f4c526ae3398960a1c2a07dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the content of the slice is a <a href="https://en.wikipedia.org/wiki/Base64">Base64</a> dump.  <a href="structmdbx_1_1slice.html#a5a35763f4c526ae3398960a1c2a07dd2">More...</a><br /></td></tr>
<tr class="separator:a5a35763f4c526ae3398960a1c2a07dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2f0695e60542de8f55001ce0f80a5b"><td class="memTemplParams" colspan="2">template&lt;class C , class T &gt; </td></tr>
<tr class="memitem:a3c2f0695e60542de8f55001ce0f80a5b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__api__macros.html#ga4912ff2f7d4f6a15b96c54e5cf8ee0f5">MDBX_CXX11_CONSTEXPR</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a3c2f0695e60542de8f55001ce0f80a5b">operator::std::basic_string_view</a> () const noexcept</td></tr>
<tr class="memdesc:a3c2f0695e60542de8f55001ce0f80a5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a string_view that references the same data as this slice.  <a href="structmdbx_1_1slice.html#a3c2f0695e60542de8f55001ce0f80a5b">More...</a><br /></td></tr>
<tr class="separator:a3c2f0695e60542de8f55001ce0f80a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55710b770fc853bf6e83c3c6e279fa27"><td class="memTemplParams" colspan="2">template&lt;class C  = char, class T  = ::std::char_traits&lt;C&gt;&gt; </td></tr>
<tr class="memitem:a55710b770fc853bf6e83c3c6e279fa27"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__api__macros.html#ga4912ff2f7d4f6a15b96c54e5cf8ee0f5">MDBX_CXX11_CONSTEXPR</a> ::std::basic_string_view&lt; C, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a55710b770fc853bf6e83c3c6e279fa27">string_view</a> () const noexcept</td></tr>
<tr class="memdesc:a55710b770fc853bf6e83c3c6e279fa27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a string_view that references the same data as this slice.  <a href="structmdbx_1_1slice.html#a55710b770fc853bf6e83c3c6e279fa27">More...</a><br /></td></tr>
<tr class="separator:a55710b770fc853bf6e83c3c6e279fa27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33c21b201a228386fbafbde3fedd04b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a33c21b201a228386fbafbde3fedd04b3">swap</a> (<a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;other) noexcept</td></tr>
<tr class="separator:a33c21b201a228386fbafbde3fedd04b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf561990846e991c8a30b57494edc82"><td class="memTemplParams" colspan="2">template&lt;class C , class T &gt; </td></tr>
<tr class="memitem:a4cf561990846e991c8a30b57494edc82"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a4cf561990846e991c8a30b57494edc82">swap</a> (::std::basic_string_view&lt; C, T &gt; &amp;view) noexcept</td></tr>
<tr class="separator:a4cf561990846e991c8a30b57494edc82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88088ec2526bb93fd7bb156b816e54e9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__api__macros.html#ga4912ff2f7d4f6a15b96c54e5cf8ee0f5">MDBX_CXX11_CONSTEXPR</a> <a class="el" href="namespacemdbx.html#acf30affbf4d2cbbaf4e41effd5196306">byte</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a88088ec2526bb93fd7bb156b816e54e9">byte_ptr</a> () const noexcept</td></tr>
<tr class="memdesc:a88088ec2526bb93fd7bb156b816e54e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns casted to pointer to byte an address of data.  <a href="structmdbx_1_1slice.html#a88088ec2526bb93fd7bb156b816e54e9">More...</a><br /></td></tr>
<tr class="separator:a88088ec2526bb93fd7bb156b816e54e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2dda0be2af6f0e3983a7dd181265240"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__api__macros.html#ga4912ff2f7d4f6a15b96c54e5cf8ee0f5">MDBX_CXX11_CONSTEXPR</a> char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#ad2dda0be2af6f0e3983a7dd181265240">char_ptr</a> () const noexcept</td></tr>
<tr class="memdesc:ad2dda0be2af6f0e3983a7dd181265240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns casted to pointer to char an address of data.  <a href="structmdbx_1_1slice.html#ad2dda0be2af6f0e3983a7dd181265240">More...</a><br /></td></tr>
<tr class="separator:ad2dda0be2af6f0e3983a7dd181265240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae091e45b34d5225d488e3423fe2b634d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__api__macros.html#ga4912ff2f7d4f6a15b96c54e5cf8ee0f5">MDBX_CXX11_CONSTEXPR</a> void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#ae091e45b34d5225d488e3423fe2b634d">data</a> () const noexcept</td></tr>
<tr class="memdesc:ae091e45b34d5225d488e3423fe2b634d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the beginning of the referenced data.  <a href="structmdbx_1_1slice.html#ae091e45b34d5225d488e3423fe2b634d">More...</a><br /></td></tr>
<tr class="separator:ae091e45b34d5225d488e3423fe2b634d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a7589156ae9a4de2f66bd79cefeb7c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__api__macros.html#ga4912ff2f7d4f6a15b96c54e5cf8ee0f5">MDBX_CXX11_CONSTEXPR</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a9a7589156ae9a4de2f66bd79cefeb7c7">length</a> () const noexcept</td></tr>
<tr class="memdesc:a9a7589156ae9a4de2f66bd79cefeb7c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bytes.  <a href="structmdbx_1_1slice.html#a9a7589156ae9a4de2f66bd79cefeb7c7">More...</a><br /></td></tr>
<tr class="separator:a9a7589156ae9a4de2f66bd79cefeb7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a366745bd8a3e693d0ea8a7b0d59d96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__api__macros.html#ga4912ff2f7d4f6a15b96c54e5cf8ee0f5">MDBX_CXX11_CONSTEXPR</a> <a class="el" href="group__api__macros.html#gabb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a7a366745bd8a3e693d0ea8a7b0d59d96">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a7a366745bd8a3e693d0ea8a7b0d59d96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the slice is empty.  <a href="structmdbx_1_1slice.html#a7a366745bd8a3e693d0ea8a7b0d59d96">More...</a><br /></td></tr>
<tr class="separator:a7a366745bd8a3e693d0ea8a7b0d59d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe0310c3746965f092f30de6807c2c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__api__macros.html#ga4912ff2f7d4f6a15b96c54e5cf8ee0f5">MDBX_CXX11_CONSTEXPR</a> <a class="el" href="group__api__macros.html#gabb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a4fe0310c3746965f092f30de6807c2c6">is_null</a> () const noexcept</td></tr>
<tr class="memdesc:a4fe0310c3746965f092f30de6807c2c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the slice data pointer is nullptr.  <a href="structmdbx_1_1slice.html#a4fe0310c3746965f092f30de6807c2c6">More...</a><br /></td></tr>
<tr class="separator:a4fe0310c3746965f092f30de6807c2c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f2b59fdcc601375fcf632c9fe131d25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__api__macros.html#ga4912ff2f7d4f6a15b96c54e5cf8ee0f5">MDBX_CXX11_CONSTEXPR</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a3f2b59fdcc601375fcf632c9fe131d25">size</a> () const noexcept</td></tr>
<tr class="memdesc:a3f2b59fdcc601375fcf632c9fe131d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bytes.  <a href="structmdbx_1_1slice.html#a3f2b59fdcc601375fcf632c9fe131d25">More...</a><br /></td></tr>
<tr class="separator:a3f2b59fdcc601375fcf632c9fe131d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a387106fb57a63d14426738ab354b979e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__api__macros.html#ga4912ff2f7d4f6a15b96c54e5cf8ee0f5">MDBX_CXX11_CONSTEXPR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a387106fb57a63d14426738ab354b979e">operator bool</a> () const noexcept</td></tr>
<tr class="memdesc:a387106fb57a63d14426738ab354b979e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if slice is not empty.  <a href="structmdbx_1_1slice.html#a387106fb57a63d14426738ab354b979e">More...</a><br /></td></tr>
<tr class="separator:a387106fb57a63d14426738ab354b979e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd1e9c857f06f54e08bfa187bf243fe1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#afd1e9c857f06f54e08bfa187bf243fe1">invalidate</a> () noexcept</td></tr>
<tr class="memdesc:afd1e9c857f06f54e08bfa187bf243fe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Depletes content of slice and make it invalid.  <a href="structmdbx_1_1slice.html#afd1e9c857f06f54e08bfa187bf243fe1">More...</a><br /></td></tr>
<tr class="separator:afd1e9c857f06f54e08bfa187bf243fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48bf7dabdbc3e3c5902cb8cb5dc9eab0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a48bf7dabdbc3e3c5902cb8cb5dc9eab0">clear</a> () noexcept</td></tr>
<tr class="memdesc:a48bf7dabdbc3e3c5902cb8cb5dc9eab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes the slice empty and referencing to nothing.  <a href="structmdbx_1_1slice.html#a48bf7dabdbc3e3c5902cb8cb5dc9eab0">More...</a><br /></td></tr>
<tr class="separator:a48bf7dabdbc3e3c5902cb8cb5dc9eab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cd0982cb9fa6eed01a48fc05c8c7ec1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a9cd0982cb9fa6eed01a48fc05c8c7ec1">remove_prefix</a> (size_t n) noexcept</td></tr>
<tr class="memdesc:a9cd0982cb9fa6eed01a48fc05c8c7ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops the first "n" bytes from this slice.  <a href="structmdbx_1_1slice.html#a9cd0982cb9fa6eed01a48fc05c8c7ec1">More...</a><br /></td></tr>
<tr class="separator:a9cd0982cb9fa6eed01a48fc05c8c7ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c89ebdb77acb3f278b50c680e8b7d07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a1c89ebdb77acb3f278b50c680e8b7d07">remove_suffix</a> (size_t n) noexcept</td></tr>
<tr class="memdesc:a1c89ebdb77acb3f278b50c680e8b7d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops the last "n" bytes from this slice.  <a href="structmdbx_1_1slice.html#a1c89ebdb77acb3f278b50c680e8b7d07">More...</a><br /></td></tr>
<tr class="separator:a1c89ebdb77acb3f278b50c680e8b7d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fbe96f44c47c47bb524a80e2172a2ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a6fbe96f44c47c47bb524a80e2172a2ee">safe_remove_prefix</a> (size_t n)</td></tr>
<tr class="memdesc:a6fbe96f44c47c47bb524a80e2172a2ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops the first "n" bytes from this slice.  <a href="structmdbx_1_1slice.html#a6fbe96f44c47c47bb524a80e2172a2ee">More...</a><br /></td></tr>
<tr class="separator:a6fbe96f44c47c47bb524a80e2172a2ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f8c368da6326b7c1d7b639e75a14a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a96f8c368da6326b7c1d7b639e75a14a6">safe_remove_suffix</a> (size_t n)</td></tr>
<tr class="memdesc:a96f8c368da6326b7c1d7b639e75a14a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops the last "n" bytes from this slice.  <a href="structmdbx_1_1slice.html#a96f8c368da6326b7c1d7b639e75a14a6">More...</a><br /></td></tr>
<tr class="separator:a96f8c368da6326b7c1d7b639e75a14a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a146d36fac778170958a1cd2ab4437"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__api__macros.html#gad5691bbd85b2cd95f66e527e46b50d3e">MDBX_NOTHROW_PURE_FUNCTION</a> <a class="el" href="group__api__macros.html#gabb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a91a146d36fac778170958a1cd2ab4437">starts_with</a> (const <a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;prefix) const noexcept</td></tr>
<tr class="memdesc:a91a146d36fac778170958a1cd2ab4437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the data starts with the given prefix.  <a href="structmdbx_1_1slice.html#a91a146d36fac778170958a1cd2ab4437">More...</a><br /></td></tr>
<tr class="separator:a91a146d36fac778170958a1cd2ab4437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a43eaf8c80843b46f623bc493222781"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__api__macros.html#gad5691bbd85b2cd95f66e527e46b50d3e">MDBX_NOTHROW_PURE_FUNCTION</a> <a class="el" href="group__api__macros.html#gabb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a4a43eaf8c80843b46f623bc493222781">ends_with</a> (const <a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;suffix) const noexcept</td></tr>
<tr class="memdesc:a4a43eaf8c80843b46f623bc493222781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the data ends with the given suffix.  <a href="structmdbx_1_1slice.html#a4a43eaf8c80843b46f623bc493222781">More...</a><br /></td></tr>
<tr class="separator:a4a43eaf8c80843b46f623bc493222781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b4684b8115062a6eeb332f08a0fecc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemdbx.html#acf30affbf4d2cbbaf4e41effd5196306">byte</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a77b4684b8115062a6eeb332f08a0fecc">operator[]</a> (size_t n) const noexcept</td></tr>
<tr class="memdesc:a77b4684b8115062a6eeb332f08a0fecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the nth byte in the referenced data.  <a href="structmdbx_1_1slice.html#a77b4684b8115062a6eeb332f08a0fecc">More...</a><br /></td></tr>
<tr class="separator:a77b4684b8115062a6eeb332f08a0fecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f1b4707a8a469f9990951fde23d30bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemdbx.html#acf30affbf4d2cbbaf4e41effd5196306">byte</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a8f1b4707a8a469f9990951fde23d30bb">at</a> (size_t n) const</td></tr>
<tr class="memdesc:a8f1b4707a8a469f9990951fde23d30bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the nth byte in the referenced data with bounds checking.  <a href="structmdbx_1_1slice.html#a8f1b4707a8a469f9990951fde23d30bb">More...</a><br /></td></tr>
<tr class="separator:a8f1b4707a8a469f9990951fde23d30bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44351506fa137dcc32ca4e02c5eb7cbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmdbx_1_1slice.html">slice</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a44351506fa137dcc32ca4e02c5eb7cbd">head</a> (size_t n) const noexcept</td></tr>
<tr class="memdesc:a44351506fa137dcc32ca4e02c5eb7cbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first "n" bytes of the slice.  <a href="structmdbx_1_1slice.html#a44351506fa137dcc32ca4e02c5eb7cbd">More...</a><br /></td></tr>
<tr class="separator:a44351506fa137dcc32ca4e02c5eb7cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3abf94daa6077ebbf429187c2029086"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmdbx_1_1slice.html">slice</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#aa3abf94daa6077ebbf429187c2029086">tail</a> (size_t n) const noexcept</td></tr>
<tr class="memdesc:aa3abf94daa6077ebbf429187c2029086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last "n" bytes of the slice.  <a href="structmdbx_1_1slice.html#aa3abf94daa6077ebbf429187c2029086">More...</a><br /></td></tr>
<tr class="separator:aa3abf94daa6077ebbf429187c2029086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18385566c1dbefe195f19292b9ca2c3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmdbx_1_1slice.html">slice</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a18385566c1dbefe195f19292b9ca2c3f">middle</a> (size_t from, size_t n) const noexcept</td></tr>
<tr class="memdesc:a18385566c1dbefe195f19292b9ca2c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the middle "n" bytes of the slice.  <a href="structmdbx_1_1slice.html#a18385566c1dbefe195f19292b9ca2c3f">More...</a><br /></td></tr>
<tr class="separator:a18385566c1dbefe195f19292b9ca2c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d2f66875e4ffc47c76f577d32bff5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmdbx_1_1slice.html">slice</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a87d2f66875e4ffc47c76f577d32bff5d">safe_head</a> (size_t n) const</td></tr>
<tr class="memdesc:a87d2f66875e4ffc47c76f577d32bff5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first "n" bytes of the slice.  <a href="structmdbx_1_1slice.html#a87d2f66875e4ffc47c76f577d32bff5d">More...</a><br /></td></tr>
<tr class="separator:a87d2f66875e4ffc47c76f577d32bff5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a696ca1e1dc1bad744f5d132c49eb8847"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmdbx_1_1slice.html">slice</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a696ca1e1dc1bad744f5d132c49eb8847">safe_tail</a> (size_t n) const</td></tr>
<tr class="memdesc:a696ca1e1dc1bad744f5d132c49eb8847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last "n" bytes of the slice.  <a href="structmdbx_1_1slice.html#a696ca1e1dc1bad744f5d132c49eb8847">More...</a><br /></td></tr>
<tr class="separator:a696ca1e1dc1bad744f5d132c49eb8847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87248db88360ce8adfa4c6dd024006e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmdbx_1_1slice.html">slice</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a87248db88360ce8adfa4c6dd024006e8">safe_middle</a> (size_t from, size_t n) const</td></tr>
<tr class="memdesc:a87248db88360ce8adfa4c6dd024006e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the middle "n" bytes of the slice.  <a href="structmdbx_1_1slice.html#a87248db88360ce8adfa4c6dd024006e8">More...</a><br /></td></tr>
<tr class="separator:a87248db88360ce8adfa4c6dd024006e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd3cb44249285b41e32cb2508e900fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__api__macros.html#gad5691bbd85b2cd95f66e527e46b50d3e">MDBX_NOTHROW_PURE_FUNCTION</a> <a class="el" href="group__api__macros.html#gad12bcc78029f8edc91982e1bac29eeb9">MDBX_CXX14_CONSTEXPR</a> size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a8bd3cb44249285b41e32cb2508e900fb">hash_value</a> () const noexcept</td></tr>
<tr class="memdesc:a8bd3cb44249285b41e32cb2508e900fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the hash value of referenced data.  <a href="structmdbx_1_1slice.html#a8bd3cb44249285b41e32cb2508e900fb">More...</a><br /></td></tr>
<tr class="separator:a8bd3cb44249285b41e32cb2508e900fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3bf067eaa40232827978d685d212d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__api__macros.html#ga4912ff2f7d4f6a15b96c54e5cf8ee0f5">MDBX_CXX11_CONSTEXPR</a> <a class="el" href="group__api__macros.html#gabb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a0e3bf067eaa40232827978d685d212d1">is_valid</a> () const noexcept</td></tr>
<tr class="memdesc:a0e3bf067eaa40232827978d685d212d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the slice is not refers to null address or has zero length.  <a href="structmdbx_1_1slice.html#a0e3bf067eaa40232827978d685d212d1">More...</a><br /></td></tr>
<tr class="separator:a0e3bf067eaa40232827978d685d212d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e9ac0c4cfe32de545311efc1f175943"><td class="memTemplParams" colspan="2">template&lt;class ALLOCATOR &gt; </td></tr>
<tr class="memitem:a7e9ac0c4cfe32de545311efc1f175943"><td class="memTemplItemLeft" align="right" valign="top">inline ::<a class="el" href="namespacemdbx.html#a8dd1a3685fba824adcf008ce1e91c8f9">mdbx::string</a>&lt; ALLOCATOR &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a7e9ac0c4cfe32de545311efc1f175943">hex_encode</a> (<a class="el" href="group__api__macros.html#gabb452686968e48b67397da5f97445f5b">bool</a> uppercase, const ALLOCATOR &amp;allocator) const</td></tr>
<tr class="separator:a7e9ac0c4cfe32de545311efc1f175943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee4fab30dd34c753e7d0040e291d9b47"><td class="memTemplParams" colspan="2">template&lt;class ALLOCATOR &gt; </td></tr>
<tr class="memitem:aee4fab30dd34c753e7d0040e291d9b47"><td class="memTemplItemLeft" align="right" valign="top">inline ::<a class="el" href="namespacemdbx.html#a8dd1a3685fba824adcf008ce1e91c8f9">mdbx::string</a>&lt; ALLOCATOR &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#aee4fab30dd34c753e7d0040e291d9b47">hex_decode</a> (const ALLOCATOR &amp;allocator) const</td></tr>
<tr class="separator:aee4fab30dd34c753e7d0040e291d9b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba9ebb3981fe89b4cae9945217ec5a27"><td class="memTemplParams" colspan="2">template&lt;class ALLOCATOR &gt; </td></tr>
<tr class="memitem:aba9ebb3981fe89b4cae9945217ec5a27"><td class="memTemplItemLeft" align="right" valign="top">inline ::<a class="el" href="namespacemdbx.html#a8dd1a3685fba824adcf008ce1e91c8f9">mdbx::string</a>&lt; ALLOCATOR &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#aba9ebb3981fe89b4cae9945217ec5a27">base58_encode</a> (const ALLOCATOR &amp;allocator) const</td></tr>
<tr class="separator:aba9ebb3981fe89b4cae9945217ec5a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1594e3687543c4bb3e500b808d16291"><td class="memTemplParams" colspan="2">template&lt;class ALLOCATOR &gt; </td></tr>
<tr class="memitem:ae1594e3687543c4bb3e500b808d16291"><td class="memTemplItemLeft" align="right" valign="top">inline ::<a class="el" href="namespacemdbx.html#a8dd1a3685fba824adcf008ce1e91c8f9">mdbx::string</a>&lt; ALLOCATOR &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#ae1594e3687543c4bb3e500b808d16291">base58_decode</a> (const ALLOCATOR &amp;allocator) const</td></tr>
<tr class="separator:ae1594e3687543c4bb3e500b808d16291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0084186aeded82f19ddb2e6868196890"><td class="memTemplParams" colspan="2">template&lt;class ALLOCATOR &gt; </td></tr>
<tr class="memitem:a0084186aeded82f19ddb2e6868196890"><td class="memTemplItemLeft" align="right" valign="top">inline ::<a class="el" href="namespacemdbx.html#a8dd1a3685fba824adcf008ce1e91c8f9">mdbx::string</a>&lt; ALLOCATOR &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a0084186aeded82f19ddb2e6868196890">base64_encode</a> (const ALLOCATOR &amp;allocator) const</td></tr>
<tr class="separator:a0084186aeded82f19ddb2e6868196890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a031e3bd4a2aa86676d89aa7243ebe347"><td class="memTemplParams" colspan="2">template&lt;class ALLOCATOR &gt; </td></tr>
<tr class="memitem:a031e3bd4a2aa86676d89aa7243ebe347"><td class="memTemplItemLeft" align="right" valign="top">inline ::<a class="el" href="namespacemdbx.html#a8dd1a3685fba824adcf008ce1e91c8f9">mdbx::string</a>&lt; ALLOCATOR &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a031e3bd4a2aa86676d89aa7243ebe347">base64_decode</a> (const ALLOCATOR &amp;allocator) const</td></tr>
<tr class="separator:a031e3bd4a2aa86676d89aa7243ebe347"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a46de2d2ffccf2b5f153b9d2d74120e45"><td class="memTemplParams" colspan="2">template&lt;size_t SIZE&gt; </td></tr>
<tr class="memitem:a46de2d2ffccf2b5f153b9d2d74120e45"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="group__api__macros.html#gad12bcc78029f8edc91982e1bac29eeb9">MDBX_CXX14_CONSTEXPR</a> <a class="el" href="structmdbx_1_1slice.html">slice</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a46de2d2ffccf2b5f153b9d2d74120e45">wrap</a> (const char(&amp;text)[SIZE])</td></tr>
<tr class="separator:a46de2d2ffccf2b5f153b9d2d74120e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3356e3700bd7172c939060241d3a991"><td class="memTemplParams" colspan="2">template&lt;typename POD &gt; </td></tr>
<tr class="memitem:af3356e3700bd7172c939060241d3a991"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="group__api__macros.html#gad12bcc78029f8edc91982e1bac29eeb9">MDBX_CXX14_CONSTEXPR</a> <a class="el" href="structmdbx_1_1slice.html">slice</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#af3356e3700bd7172c939060241d3a991">wrap</a> (const POD &amp;pod)</td></tr>
<tr class="separator:af3356e3700bd7172c939060241d3a991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae49370bd45c2ab41aba34be70bb42314"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__api__macros.html#gad5691bbd85b2cd95f66e527e46b50d3e">MDBX_NOTHROW_PURE_FUNCTION</a> intptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#ae49370bd45c2ab41aba34be70bb42314">compare_fast</a> (const <a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;a, const <a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;b) noexcept</td></tr>
<tr class="memdesc:ae49370bd45c2ab41aba34be70bb42314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Three-way fast non-lexicographically length-based comparison.  <a href="structmdbx_1_1slice.html#ae49370bd45c2ab41aba34be70bb42314">More...</a><br /></td></tr>
<tr class="separator:ae49370bd45c2ab41aba34be70bb42314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a11fae50e5e10f39313ab31d6386a8a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__api__macros.html#gad5691bbd85b2cd95f66e527e46b50d3e">MDBX_NOTHROW_PURE_FUNCTION</a> intptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a7a11fae50e5e10f39313ab31d6386a8a">compare_lexicographically</a> (const <a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;a, const <a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;b) noexcept</td></tr>
<tr class="memdesc:a7a11fae50e5e10f39313ab31d6386a8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Three-way lexicographically comparison.  <a href="structmdbx_1_1slice.html#a7a11fae50e5e10f39313ab31d6386a8a">More...</a><br /></td></tr>
<tr class="separator:a7a11fae50e5e10f39313ab31d6386a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af64d34b0ad215c1612c16dd3e1ecda44"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__api__macros.html#ga4912ff2f7d4f6a15b96c54e5cf8ee0f5">MDBX_CXX11_CONSTEXPR</a> <a class="el" href="structmdbx_1_1slice.html">slice</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#af64d34b0ad215c1612c16dd3e1ecda44">invalid</a> () noexcept</td></tr>
<tr class="memdesc:af64d34b0ad215c1612c16dd3e1ecda44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build an invalid slice which non-zero length and refers to null address.  <a href="structmdbx_1_1slice.html#af64d34b0ad215c1612c16dd3e1ecda44">More...</a><br /></td></tr>
<tr class="separator:af64d34b0ad215c1612c16dd3e1ecda44"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a4f87cac243174f18616e71c2419820e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__api__macros.html#ga4912ff2f7d4f6a15b96c54e5cf8ee0f5">MDBX_CXX11_CONSTEXPR</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a4f87cac243174f18616e71c2419820e9">slice</a> (size_t invalid_length) noexcept</td></tr>
<tr class="separator:a4f87cac243174f18616e71c2419820e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aa11b3c7589162ca7be1a433924adc77b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__api__macros.html#gabb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#aa11b3c7589162ca7be1a433924adc77b">operator==</a> (const <a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;a, const <a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;b) noexcept</td></tr>
<tr class="separator:aa11b3c7589162ca7be1a433924adc77b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7349d8724735c67f5bf06550c8f1fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__api__macros.html#gabb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#adb7349d8724735c67f5bf06550c8f1fe">operator&lt;</a> (const <a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;a, const <a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;b) noexcept</td></tr>
<tr class="separator:adb7349d8724735c67f5bf06550c8f1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a038605fe8f60588b31f7872b1411c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__api__macros.html#gabb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a0a038605fe8f60588b31f7872b1411c9">operator&gt;</a> (const <a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;a, const <a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;b) noexcept</td></tr>
<tr class="separator:a0a038605fe8f60588b31f7872b1411c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2071047a9332799185ac96798730ed4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__api__macros.html#gabb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a2071047a9332799185ac96798730ed4a">operator&lt;=</a> (const <a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;a, const <a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;b) noexcept</td></tr>
<tr class="separator:a2071047a9332799185ac96798730ed4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3876d218971e4e5ea14092c070638d7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__api__macros.html#gabb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#a3876d218971e4e5ea14092c070638d7b">operator&gt;=</a> (const <a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;a, const <a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;b) noexcept</td></tr>
<tr class="separator:a3876d218971e4e5ea14092c070638d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7e1c7159660896d5573d92dd57c5ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__api__macros.html#gabb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmdbx_1_1slice.html#aaa7e1c7159660896d5573d92dd57c5ca">operator!=</a> (const <a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;a, const <a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;b) noexcept</td></tr>
<tr class="separator:aaa7e1c7159660896d5573d92dd57c5ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>References a data located outside the slice. </p>
<p>The <code>slice</code> is similar in many ways to <code>std::string_view</code>, but it implements specific capabilities and manipulates with bytes but not a characters.</p>
<p><a class="anchor" id="MDBX_val"></a></p><dl class="section see"><dt>See also</dt><dd><a class="el" href="structmdbx_1_1slice.html" title="References a data located outside the slice.">mdbx::slice</a> </dd>
<dd>
<a class="el" href="classmdbx_1_1buffer.html" title="The chunk of data stored inside the buffer or located outside it.">mdbx::buffer</a></dd></dl>
<p>Values returned from the database are valid only until a subsequent update operation, or the end of the transaction. Do not modify or free them, they commonly point into the database itself.</p>
<p>Key sizes must be between 0 and <a class="el" href="group__c__statinfo.html#ga35f67460a9d405b8c29e4b5d18360993">mdbx_env_get_maxkeysize()</a> inclusive. The same applies to data sizes in databases with the <a class="el" href="group__c__dbi.html#ggafe3bddb297b3ab0d828a487c5726f76aaed33d978b4e23b7c1659e8106e9c7acd">MDBX_DUPSORT</a> flag. Other data items can in theory be from 0 to <a class="el" href="group__c__api.html#gga190b5c6e7f916f612c5819e1ab8acfdfa92ddaf7c24c6a036bce86f28e9d60f2f">MDBX_MAXDATASIZE</a> bytes long.</p>
<dl class="section note"><dt>Note</dt><dd>The notable difference between MDBX and LMDB is that MDBX support zero length keys. </dd></dl>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a3c416cc79e62785145d10a7ac4dbfc91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c416cc79e62785145d10a7ac4dbfc91">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3c416cc79e62785145d10a7ac4dbfc91a2d53525f1ae978c25b11c334cb0c20c0"></a>max_length&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3ae8bc090ddbf0840e7403caa4c1340e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ae8bc090ddbf0840e7403caa4c1340e">&#9670;&nbsp;</a></span>slice() <span class="overload">[1/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api__macros.html#ga4912ff2f7d4f6a15b96c54e5cf8ee0f5">MDBX_CXX11_CONSTEXPR</a> mdbx::slice::slice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an empty slice. </p>

</div>
</div>
<a id="ad49be025821f597622feeb197080a5e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad49be025821f597622feeb197080a5e7">&#9670;&nbsp;</a></span>slice() <span class="overload">[2/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api__macros.html#gad12bcc78029f8edc91982e1bac29eeb9">MDBX_CXX14_CONSTEXPR</a> mdbx::slice::slice </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a slice that refers to [0,bytes-1] of memory bytes pointed by ptr. </p>

</div>
</div>
<a id="a89bfac035eab040a04c60396473d4395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89bfac035eab040a04c60396473d4395">&#9670;&nbsp;</a></span>slice() <span class="overload">[3/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api__macros.html#gad12bcc78029f8edc91982e1bac29eeb9">MDBX_CXX14_CONSTEXPR</a> mdbx::slice::slice </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a slice that refers to [begin,end] of memory bytes. </p>

</div>
</div>
<a id="aa4e488667b0dee1cdcee2fe9efa50c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4e488667b0dee1cdcee2fe9efa50c22">&#9670;&nbsp;</a></span>slice() <span class="overload">[4/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api__macros.html#gad12bcc78029f8edc91982e1bac29eeb9">MDBX_CXX14_CONSTEXPR</a> mdbx::slice::slice </td>
          <td>(</td>
          <td class="paramtype">const char(&amp;)&#160;</td>
          <td class="paramname"><em>text</em>[SIZE]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a slice that refers to text[0,strlen(text)-1]. </p>

</div>
</div>
<a id="a770a0604402b734d0df2d1fce7fec2c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a770a0604402b734d0df2d1fce7fec2c5">&#9670;&nbsp;</a></span>slice() <span class="overload">[5/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mdbx_8h_09_09.html#ac481c8c5dbfd2f48685ea99bcbc4c5e0">MDBX_CXX17_CONSTEXPR</a> mdbx::slice::slice </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>c_str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a slice that refers to c_str[0,strlen(c_str)-1]. </p>

</div>
</div>
<a id="a98a52b59efcfde3319c0a7ea6244fe51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98a52b59efcfde3319c0a7ea6244fe51">&#9670;&nbsp;</a></span>slice() <span class="overload">[6/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , class T , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mdbx_8h_09_09.html#a006b5a41dcea1c018efaa0b36fb94cc5">MDBX_CXX20_CONSTEXPR</a> mdbx::slice::slice </td>
          <td>(</td>
          <td class="paramtype">const ::std::basic_string&lt; C, T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a slice that refers to the contents of "str". </p>

</div>
</div>
<a id="af8c6d4f4718fa2251dc3980e19e3973c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8c6d4f4718fa2251dc3980e19e3973c">&#9670;&nbsp;</a></span>slice() <span class="overload">[7/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api__macros.html#gad12bcc78029f8edc91982e1bac29eeb9">MDBX_CXX14_CONSTEXPR</a> mdbx::slice::slice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__c__api.html#ga5eedfc4a83296bbf0f8ff93359cb0900">MDBX_val</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1bd3d8e8cc1e7676767cb14b657facb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bd3d8e8cc1e7676767cb14b657facb9">&#9670;&nbsp;</a></span>slice() <span class="overload">[8/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api__macros.html#ga4912ff2f7d4f6a15b96c54e5cf8ee0f5">MDBX_CXX11_CONSTEXPR</a> mdbx::slice::slice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac6358af305d1dffdbfa5e2851ccb30a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6358af305d1dffdbfa5e2851ccb30a1">&#9670;&nbsp;</a></span>slice() <span class="overload">[9/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api__macros.html#gad12bcc78029f8edc91982e1bac29eeb9">MDBX_CXX14_CONSTEXPR</a> mdbx::slice::slice </td>
          <td>(</td>
          <td class="paramtype">const ::std::basic_string_view&lt; C, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a slice that refers to the same contents as "sv". </p>

</div>
</div>
<a id="ab4cb9f5defb50c0bc85a5961c4979391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4cb9f5defb50c0bc85a5961c4979391">&#9670;&nbsp;</a></span>slice() <span class="overload">[10/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mdbx::slice::slice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__c__api.html#ga5eedfc4a83296bbf0f8ff93359cb0900">MDBX_val</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aad2b4b4181c6e71f9e298172e718ebe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad2b4b4181c6e71f9e298172e718ebe7">&#9670;&nbsp;</a></span>slice() <span class="overload">[11/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mdbx::slice::slice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8e55976f373982c3316f53eef0cc87fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e55976f373982c3316f53eef0cc87fa">&#9670;&nbsp;</a></span>slice() <span class="overload">[12/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mdbx::slice::slice </td>
          <td>(</td>
          <td class="paramtype">::std::basic_string_view&lt; C, T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>sv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f87cac243174f18616e71c2419820e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f87cac243174f18616e71c2419820e9">&#9670;&nbsp;</a></span>slice() <span class="overload">[13/13]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api__macros.html#ga4912ff2f7d4f6a15b96c54e5cf8ee0f5">MDBX_CXX11_CONSTEXPR</a> mdbx::slice::slice </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>invalid_length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5993b2fba342e7334a3b1867fc8f9e26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5993b2fba342e7334a3b1867fc8f9e26">&#9670;&nbsp;</a></span>assign() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmdbx_1_1slice.html">slice</a> &amp; mdbx::slice::assign </td>
          <td>(</td>
          <td class="paramtype">::<a class="el" href="group__c__api.html#ga5eedfc4a83296bbf0f8ff93359cb0900">MDBX_val</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2f00aa7e03405e8bfce4ecab87dd39b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f00aa7e03405e8bfce4ecab87dd39b6">&#9670;&nbsp;</a></span>assign() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmdbx_1_1slice.html">slice</a>&amp; mdbx::slice::assign </td>
          <td>(</td>
          <td class="paramtype">::std::basic_string_view&lt; C, T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>view</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a39cd2a1bf72b7eb2f45fc066368be24e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39cd2a1bf72b7eb2f45fc066368be24e">&#9670;&nbsp;</a></span>assign() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmdbx_1_1slice.html">slice</a> &amp; mdbx::slice::assign </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="group__c__api.html#ga5eedfc4a83296bbf0f8ff93359cb0900">MDBX_val</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac114cb2638e97a3d60fef3124d4ee4cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac114cb2638e97a3d60fef3124d4ee4cf">&#9670;&nbsp;</a></span>assign() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , class T , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmdbx_1_1slice.html">slice</a>&amp; mdbx::slice::assign </td>
          <td>(</td>
          <td class="paramtype">const ::std::basic_string&lt; C, T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab15034a2f9fb9826615d1ef8f81ecadb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab15034a2f9fb9826615d1ef8f81ecadb">&#9670;&nbsp;</a></span>assign() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmdbx_1_1slice.html">slice</a>&amp; mdbx::slice::assign </td>
          <td>(</td>
          <td class="paramtype">const ::std::basic_string_view&lt; C, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>view</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abb454a827ec3cfe8a7fe778bbfed301d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb454a827ec3cfe8a7fe778bbfed301d">&#9670;&nbsp;</a></span>assign() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmdbx_1_1slice.html">slice</a> &amp; mdbx::slice::assign </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>c_str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af6b0854d1b1004d154fcb7a3ed111957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6b0854d1b1004d154fcb7a3ed111957">&#9670;&nbsp;</a></span>assign() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmdbx_1_1slice.html">slice</a> &amp; mdbx::slice::assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c2a277b73fb6d72597249fe8c826ae1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c2a277b73fb6d72597249fe8c826ae1">&#9670;&nbsp;</a></span>assign() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmdbx_1_1slice.html">slice</a> &amp; mdbx::slice::assign </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1cac4c0dba09131704fc13e23e7caee8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cac4c0dba09131704fc13e23e7caee8">&#9670;&nbsp;</a></span>assign() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmdbx_1_1slice.html">slice</a> &amp; mdbx::slice::assign </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2bb10fb6c7885ffdb5668b1472ce4c61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bb10fb6c7885ffdb5668b1472ce4c61">&#9670;&nbsp;</a></span>assign() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmdbx_1_1slice.html">slice</a> &amp; mdbx::slice::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f1b4707a8a469f9990951fde23d30bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f1b4707a8a469f9990951fde23d30bb">&#9670;&nbsp;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemdbx.html#acf30affbf4d2cbbaf4e41effd5196306">byte</a> mdbx::slice::at </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the nth byte in the referenced data with bounds checking. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if <code>n &gt;= <a class="el" href="structmdbx_1_1slice.html#a3f2b59fdcc601375fcf632c9fe131d25" title="Returns the number of bytes.">size()</a></code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1594e3687543c4bb3e500b808d16291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1594e3687543c4bb3e500b808d16291">&#9670;&nbsp;</a></span>base58_decode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ALLOCATOR &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">inline ::<a class="el" href="namespacemdbx.html#a8dd1a3685fba824adcf008ce1e91c8f9">mdbx::string</a>&lt;ALLOCATOR&gt; mdbx::slice::base58_decode </td>
          <td>(</td>
          <td class="paramtype">const ALLOCATOR &amp;&#160;</td>
          <td class="paramname"><em>allocator</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae159395d655779747d0e381f210e7c39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae159395d655779747d0e381f210e7c39">&#9670;&nbsp;</a></span>base58_decode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ALLOCATOR  = legacy_allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">inline ::<a class="el" href="namespacemdbx.html#a8dd1a3685fba824adcf008ce1e91c8f9">mdbx::string</a>&lt;ALLOCATOR&gt; mdbx::slice::base58_decode </td>
          <td>(</td>
          <td class="paramtype">const ALLOCATOR &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>ALLOCATOR()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decodes <a href="https://en.wikipedia.org/wiki/Base58">Base58</a> dump from the slice content into returned data string. </p>

</div>
</div>
<a id="aba9ebb3981fe89b4cae9945217ec5a27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba9ebb3981fe89b4cae9945217ec5a27">&#9670;&nbsp;</a></span>base58_encode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ALLOCATOR &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">inline ::<a class="el" href="namespacemdbx.html#a8dd1a3685fba824adcf008ce1e91c8f9">mdbx::string</a>&lt;ALLOCATOR&gt; mdbx::slice::base58_encode </td>
          <td>(</td>
          <td class="paramtype">const ALLOCATOR &amp;&#160;</td>
          <td class="paramname"><em>allocator</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa4fafe5ed4cedea76b5dbbf5cfa26104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4fafe5ed4cedea76b5dbbf5cfa26104">&#9670;&nbsp;</a></span>base58_encode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ALLOCATOR  = legacy_allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">inline ::<a class="el" href="namespacemdbx.html#a8dd1a3685fba824adcf008ce1e91c8f9">mdbx::string</a>&lt;ALLOCATOR&gt; mdbx::slice::base58_encode </td>
          <td>(</td>
          <td class="paramtype">const ALLOCATOR &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>ALLOCATOR()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string with a <a href="https://en.wikipedia.org/wiki/Base58">Base58</a> dump of the slice content. </p>

</div>
</div>
<a id="a031e3bd4a2aa86676d89aa7243ebe347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a031e3bd4a2aa86676d89aa7243ebe347">&#9670;&nbsp;</a></span>base64_decode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ALLOCATOR &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">inline ::<a class="el" href="namespacemdbx.html#a8dd1a3685fba824adcf008ce1e91c8f9">mdbx::string</a>&lt;ALLOCATOR&gt; mdbx::slice::base64_decode </td>
          <td>(</td>
          <td class="paramtype">const ALLOCATOR &amp;&#160;</td>
          <td class="paramname"><em>allocator</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a134d5464573d2ee5f1db2fa43b9380a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a134d5464573d2ee5f1db2fa43b9380a1">&#9670;&nbsp;</a></span>base64_decode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ALLOCATOR  = legacy_allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">inline ::<a class="el" href="namespacemdbx.html#a8dd1a3685fba824adcf008ce1e91c8f9">mdbx::string</a>&lt;ALLOCATOR&gt; mdbx::slice::base64_decode </td>
          <td>(</td>
          <td class="paramtype">const ALLOCATOR &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>ALLOCATOR()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decodes <a href="https://en.wikipedia.org/wiki/Base64">Base64</a> dump from the slice content into returned data string. </p>

</div>
</div>
<a id="a0084186aeded82f19ddb2e6868196890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0084186aeded82f19ddb2e6868196890">&#9670;&nbsp;</a></span>base64_encode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ALLOCATOR &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">inline ::<a class="el" href="namespacemdbx.html#a8dd1a3685fba824adcf008ce1e91c8f9">mdbx::string</a>&lt;ALLOCATOR&gt; mdbx::slice::base64_encode </td>
          <td>(</td>
          <td class="paramtype">const ALLOCATOR &amp;&#160;</td>
          <td class="paramname"><em>allocator</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1b80d41eb4d976923af463954ad7d1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1b80d41eb4d976923af463954ad7d1f">&#9670;&nbsp;</a></span>base64_encode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ALLOCATOR  = legacy_allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">inline ::<a class="el" href="namespacemdbx.html#a8dd1a3685fba824adcf008ce1e91c8f9">mdbx::string</a>&lt;ALLOCATOR&gt; mdbx::slice::base64_encode </td>
          <td>(</td>
          <td class="paramtype">const ALLOCATOR &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>ALLOCATOR()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string with a <a href="https://en.wikipedia.org/wiki/Base64">Base64</a> dump of the slice content. </p>

</div>
</div>
<a id="a88088ec2526bb93fd7bb156b816e54e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88088ec2526bb93fd7bb156b816e54e9">&#9670;&nbsp;</a></span>byte_ptr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__api__macros.html#ga4912ff2f7d4f6a15b96c54e5cf8ee0f5">MDBX_CXX11_CONSTEXPR</a> <a class="el" href="namespacemdbx.html#acf30affbf4d2cbbaf4e41effd5196306">mdbx::byte</a> * mdbx::slice::byte_ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns casted to pointer to byte an address of data. </p>

</div>
</div>
<a id="ad2dda0be2af6f0e3983a7dd181265240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2dda0be2af6f0e3983a7dd181265240">&#9670;&nbsp;</a></span>char_ptr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__api__macros.html#ga4912ff2f7d4f6a15b96c54e5cf8ee0f5">MDBX_CXX11_CONSTEXPR</a> char * mdbx::slice::char_ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns casted to pointer to char an address of data. </p>

</div>
</div>
<a id="a48bf7dabdbc3e3c5902cb8cb5dc9eab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48bf7dabdbc3e3c5902cb8cb5dc9eab0">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mdbx::slice::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes the slice empty and referencing to nothing. </p>

</div>
</div>
<a id="ae49370bd45c2ab41aba34be70bb42314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae49370bd45c2ab41aba34be70bb42314">&#9670;&nbsp;</a></span>compare_fast()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">intptr_t mdbx::slice::compare_fast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Three-way fast non-lexicographically length-based comparison. </p>
<dl class="section return"><dt>Returns</dt><dd>value: == 0 if "a" == "b", &lt; 0 if "a" shorter than "b", <blockquote class="doxtable">
<p>0 if "a" longer than "b", </p>
</blockquote>
&lt; 0 if "a" length-equal and lexicographically less than "b", <blockquote class="doxtable">
<p>0 if "a" length-equal and lexicographically great than "b". </p>
</blockquote>
</dd></dl>

</div>
</div>
<a id="a7a11fae50e5e10f39313ab31d6386a8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a11fae50e5e10f39313ab31d6386a8a">&#9670;&nbsp;</a></span>compare_lexicographically()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">intptr_t mdbx::slice::compare_lexicographically </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Three-way lexicographically comparison. </p>
<dl class="section return"><dt>Returns</dt><dd>value: &lt; 0 if "a" &lt; "b", == 0 if "a" == "b", <blockquote class="doxtable">
<p>0 if "a" &gt; "b". </p>
</blockquote>
</dd></dl>

</div>
</div>
<a id="ae091e45b34d5225d488e3423fe2b634d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae091e45b34d5225d488e3423fe2b634d">&#9670;&nbsp;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__api__macros.html#ga4912ff2f7d4f6a15b96c54e5cf8ee0f5">MDBX_CXX11_CONSTEXPR</a> void * mdbx::slice::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to the beginning of the referenced data. </p>

</div>
</div>
<a id="a7a366745bd8a3e693d0ea8a7b0d59d96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a366745bd8a3e693d0ea8a7b0d59d96">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api__macros.html#ga4912ff2f7d4f6a15b96c54e5cf8ee0f5">MDBX_CXX11_CONSTEXPR</a> <a class="el" href="group__api__macros.html#gabb452686968e48b67397da5f97445f5b">bool</a> mdbx::slice::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the slice is empty. </p>

</div>
</div>
<a id="a4a43eaf8c80843b46f623bc493222781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a43eaf8c80843b46f623bc493222781">&#9670;&nbsp;</a></span>ends_with()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api__macros.html#gabb452686968e48b67397da5f97445f5b">bool</a> mdbx::slice::ends_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;&#160;</td>
          <td class="paramname"><em>suffix</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the data ends with the given suffix. </p>

</div>
</div>
<a id="a28ddadf607eb189ed0d8644c848ecdb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28ddadf607eb189ed0d8644c848ecdb6">&#9670;&nbsp;</a></span>from_base58()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemdbx.html#acf30affbf4d2cbbaf4e41effd5196306">byte</a>* mdbx::slice::from_base58 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemdbx.html#acf30affbf4d2cbbaf4e41effd5196306">byte</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dest_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__api__macros.html#gabb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>ignore_spaces</em> = <code><a class="el" href="group__api__macros.html#ga65e9886d74aaee76545e83dd09011727">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills the buffer with data converted from <a href="https://en.wikipedia.org/wiki/Base58">Base58</a> dump from slice content. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if given buffer is too small. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a998c93cadb9df0284f0babb758cd9870"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a998c93cadb9df0284f0babb758cd9870">&#9670;&nbsp;</a></span>from_base58_bytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api__macros.html#ga4912ff2f7d4f6a15b96c54e5cf8ee0f5">MDBX_CXX11_CONSTEXPR</a> size_t mdbx::slice::from_base58_bytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the buffer size in bytes needed for conversion <a href="https://en.wikipedia.org/wiki/Base58">Base58</a> dump to data. </p>

</div>
</div>
<a id="a63aa61531dc882114c273fe30b83ea3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63aa61531dc882114c273fe30b83ea3d">&#9670;&nbsp;</a></span>from_base64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemdbx.html#acf30affbf4d2cbbaf4e41effd5196306">byte</a>* mdbx::slice::from_base64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemdbx.html#acf30affbf4d2cbbaf4e41effd5196306">byte</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dest_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__api__macros.html#gabb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>ignore_spaces</em> = <code><a class="el" href="group__api__macros.html#ga65e9886d74aaee76545e83dd09011727">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills the buffer with data converted from <a href="https://en.wikipedia.org/wiki/Base64">Base64</a> dump. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if given buffer is too small. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac2b36f3a8f752b979152c13621d02602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2b36f3a8f752b979152c13621d02602">&#9670;&nbsp;</a></span>from_base64_bytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api__macros.html#ga4912ff2f7d4f6a15b96c54e5cf8ee0f5">MDBX_CXX11_CONSTEXPR</a> size_t mdbx::slice::from_base64_bytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the buffer size in bytes needed for conversion <a href="https://en.wikipedia.org/wiki/Base64">Base64</a> dump to data. </p>

</div>
</div>
<a id="a1ecb1a4f1c20321d8a197362915b3850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ecb1a4f1c20321d8a197362915b3850">&#9670;&nbsp;</a></span>from_hex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemdbx.html#acf30affbf4d2cbbaf4e41effd5196306">byte</a>* mdbx::slice::from_hex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemdbx.html#acf30affbf4d2cbbaf4e41effd5196306">byte</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dest_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__api__macros.html#gabb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>ignore_spaces</em> = <code><a class="el" href="group__api__macros.html#ga65e9886d74aaee76545e83dd09011727">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills the buffer with data converted from hexadecimal dump from slice content. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if given buffer is too small. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7766acc920d26c1c7ba74be42b89c327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7766acc920d26c1c7ba74be42b89c327">&#9670;&nbsp;</a></span>from_hex_bytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api__macros.html#ga4912ff2f7d4f6a15b96c54e5cf8ee0f5">MDBX_CXX11_CONSTEXPR</a> size_t mdbx::slice::from_hex_bytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the buffer size in bytes needed for conversion hexadecimal dump from slice content to data. </p>

</div>
</div>
<a id="a8bd3cb44249285b41e32cb2508e900fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bd3cb44249285b41e32cb2508e900fb">&#9670;&nbsp;</a></span>hash_value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api__macros.html#gad5691bbd85b2cd95f66e527e46b50d3e">MDBX_NOTHROW_PURE_FUNCTION</a> <a class="el" href="group__api__macros.html#gad12bcc78029f8edc91982e1bac29eeb9">MDBX_CXX14_CONSTEXPR</a> size_t mdbx::slice::hash_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the hash value of referenced data. </p>
<dl class="section attention"><dt>Attention</dt><dd>Function implementation and returned hash values may changed version to version, and in future the t1ha3 will be used here. Therefore values obtained from this function shouldn't be persisted anywhere. </dd></dl>

</div>
</div>
<a id="a44351506fa137dcc32ca4e02c5eb7cbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44351506fa137dcc32ca4e02c5eb7cbd">&#9670;&nbsp;</a></span>head()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmdbx_1_1slice.html">slice</a> mdbx::slice::head </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first "n" bytes of the slice. </p>
<dl class="section pre"><dt>Precondition</dt><dd>REQUIRES: <code>n &lt;= <a class="el" href="structmdbx_1_1slice.html#a3f2b59fdcc601375fcf632c9fe131d25" title="Returns the number of bytes.">size()</a></code> </dd></dl>

</div>
</div>
<a id="aee4fab30dd34c753e7d0040e291d9b47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee4fab30dd34c753e7d0040e291d9b47">&#9670;&nbsp;</a></span>hex_decode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ALLOCATOR &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">inline ::<a class="el" href="namespacemdbx.html#a8dd1a3685fba824adcf008ce1e91c8f9">mdbx::string</a>&lt;ALLOCATOR&gt; mdbx::slice::hex_decode </td>
          <td>(</td>
          <td class="paramtype">const ALLOCATOR &amp;&#160;</td>
          <td class="paramname"><em>allocator</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2cce5923f0ef49dd4d7b6b6e45c8a6d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cce5923f0ef49dd4d7b6b6e45c8a6d6">&#9670;&nbsp;</a></span>hex_decode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ALLOCATOR  = legacy_allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">inline ::<a class="el" href="namespacemdbx.html#a8dd1a3685fba824adcf008ce1e91c8f9">mdbx::string</a>&lt;ALLOCATOR&gt; mdbx::slice::hex_decode </td>
          <td>(</td>
          <td class="paramtype">const ALLOCATOR &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>ALLOCATOR()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decodes hexadecimal dump from the slice content into returned data string. </p>

</div>
</div>
<a id="a7e9ac0c4cfe32de545311efc1f175943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e9ac0c4cfe32de545311efc1f175943">&#9670;&nbsp;</a></span>hex_encode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ALLOCATOR &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">inline ::<a class="el" href="namespacemdbx.html#a8dd1a3685fba824adcf008ce1e91c8f9">mdbx::string</a>&lt;ALLOCATOR&gt; mdbx::slice::hex_encode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__api__macros.html#gabb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>uppercase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&#160;</td>
          <td class="paramname"><em>allocator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad647165fd9eed56bf574bcc592fe3355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad647165fd9eed56bf574bcc592fe3355">&#9670;&nbsp;</a></span>hex_encode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ALLOCATOR  = legacy_allocator&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">inline ::<a class="el" href="namespacemdbx.html#a8dd1a3685fba824adcf008ce1e91c8f9">mdbx::string</a>&lt;ALLOCATOR&gt; mdbx::slice::hex_encode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__api__macros.html#gabb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>uppercase</em> = <code><a class="el" href="group__api__macros.html#ga65e9886d74aaee76545e83dd09011727">false</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>ALLOCATOR()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string with a hexadecimal dump of the slice content. </p>

</div>
</div>
<a id="af64d34b0ad215c1612c16dd3e1ecda44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af64d34b0ad215c1612c16dd3e1ecda44">&#9670;&nbsp;</a></span>invalid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__api__macros.html#ga4912ff2f7d4f6a15b96c54e5cf8ee0f5">MDBX_CXX11_CONSTEXPR</a> <a class="el" href="structmdbx_1_1slice.html">slice</a> mdbx::slice::invalid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build an invalid slice which non-zero length and refers to null address. </p>

</div>
</div>
<a id="afd1e9c857f06f54e08bfa187bf243fe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd1e9c857f06f54e08bfa187bf243fe1">&#9670;&nbsp;</a></span>invalidate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mdbx::slice::invalidate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Depletes content of slice and make it invalid. </p>

</div>
</div>
<a id="a73da4504ae4f1b80e2fcded85ab3e473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73da4504ae4f1b80e2fcded85ab3e473">&#9670;&nbsp;</a></span>is_base58()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api__macros.html#gad5691bbd85b2cd95f66e527e46b50d3e">MDBX_NOTHROW_PURE_FUNCTION</a> <a class="el" href="group__api__macros.html#gabb452686968e48b67397da5f97445f5b">bool</a> mdbx::slice::is_base58 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__api__macros.html#gabb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>ignore_spaces</em> = <code><a class="el" href="group__api__macros.html#ga65e9886d74aaee76545e83dd09011727">false</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the content of the slice is a <a href="https://en.wikipedia.org/wiki/Base58">Base58</a> dump. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ignore_spaces</td><td>If <code>true</code> function will skips spaces surrounding (before, between and after) a encoded bytes. However, spaces should not break a code group of characters. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a35763f4c526ae3398960a1c2a07dd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a35763f4c526ae3398960a1c2a07dd2">&#9670;&nbsp;</a></span>is_base64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api__macros.html#gad5691bbd85b2cd95f66e527e46b50d3e">MDBX_NOTHROW_PURE_FUNCTION</a> <a class="el" href="group__api__macros.html#gabb452686968e48b67397da5f97445f5b">bool</a> mdbx::slice::is_base64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__api__macros.html#gabb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>ignore_spaces</em> = <code><a class="el" href="group__api__macros.html#ga65e9886d74aaee76545e83dd09011727">false</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the content of the slice is a <a href="https://en.wikipedia.org/wiki/Base64">Base64</a> dump. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ignore_spaces</td><td>If <code>true</code> function will skips spaces surrounding (before, between and after) a encoded bytes. However, spaces should not break a code group of characters. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6431627b97ee96678994888369091534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6431627b97ee96678994888369091534">&#9670;&nbsp;</a></span>is_hex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api__macros.html#gad5691bbd85b2cd95f66e527e46b50d3e">MDBX_NOTHROW_PURE_FUNCTION</a> <a class="el" href="group__api__macros.html#gabb452686968e48b67397da5f97445f5b">bool</a> mdbx::slice::is_hex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__api__macros.html#gabb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>ignore_spaces</em> = <code><a class="el" href="group__api__macros.html#ga65e9886d74aaee76545e83dd09011727">false</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the content of the slice is a hexadecimal dump. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ignore_spaces</td><td>If <code>true</code> function will skips spaces surrounding (before, between and after) a encoded bytes. However, spaces should not break a pair of characters encoding a single byte. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4fe0310c3746965f092f30de6807c2c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fe0310c3746965f092f30de6807c2c6">&#9670;&nbsp;</a></span>is_null()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api__macros.html#ga4912ff2f7d4f6a15b96c54e5cf8ee0f5">MDBX_CXX11_CONSTEXPR</a> <a class="el" href="group__api__macros.html#gabb452686968e48b67397da5f97445f5b">bool</a> mdbx::slice::is_null </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the slice data pointer is nullptr. </p>

</div>
</div>
<a id="a329fdd57ba7066275bb289ca5a86afbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a329fdd57ba7066275bb289ca5a86afbb">&#9670;&nbsp;</a></span>is_printable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api__macros.html#gad5691bbd85b2cd95f66e527e46b50d3e">MDBX_NOTHROW_PURE_FUNCTION</a> <a class="el" href="group__api__macros.html#gabb452686968e48b67397da5f97445f5b">bool</a> mdbx::slice::is_printable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__api__macros.html#gabb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>disable_utf8</em> = <code><a class="el" href="group__api__macros.html#ga65e9886d74aaee76545e83dd09011727">false</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the content of the slice is printable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">disable_utf8</td><td>By default if <code>disable_utf8</code> is <code>false</code> function checks that content bytes are printable ASCII-7 characters or a valid UTF8 sequences. Otherwise, if if <code>disable_utf8</code> is <code>true</code> function checks that content bytes are printable extended 8-bit ASCII codes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e3bf067eaa40232827978d685d212d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e3bf067eaa40232827978d685d212d1">&#9670;&nbsp;</a></span>is_valid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api__macros.html#ga4912ff2f7d4f6a15b96c54e5cf8ee0f5">MDBX_CXX11_CONSTEXPR</a> <a class="el" href="group__api__macros.html#gabb452686968e48b67397da5f97445f5b">bool</a> mdbx::slice::is_valid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks the slice is not refers to null address or has zero length. </p>

</div>
</div>
<a id="a9a7589156ae9a4de2f66bd79cefeb7c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a7589156ae9a4de2f66bd79cefeb7c7">&#9670;&nbsp;</a></span>length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api__macros.html#ga4912ff2f7d4f6a15b96c54e5cf8ee0f5">MDBX_CXX11_CONSTEXPR</a> size_t mdbx::slice::length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of bytes. </p>

</div>
</div>
<a id="a18385566c1dbefe195f19292b9ca2c3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18385566c1dbefe195f19292b9ca2c3f">&#9670;&nbsp;</a></span>middle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmdbx_1_1slice.html">slice</a> mdbx::slice::middle </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the middle "n" bytes of the slice. </p>
<dl class="section pre"><dt>Precondition</dt><dd>REQUIRES: <code>from + n &lt;= <a class="el" href="structmdbx_1_1slice.html#a3f2b59fdcc601375fcf632c9fe131d25" title="Returns the number of bytes.">size()</a></code> </dd></dl>

</div>
</div>
<a id="a387106fb57a63d14426738ab354b979e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a387106fb57a63d14426738ab354b979e">&#9670;&nbsp;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api__macros.html#ga4912ff2f7d4f6a15b96c54e5cf8ee0f5">MDBX_CXX11_CONSTEXPR</a> mdbx::slice::operator <a class="el" href="group__api__macros.html#gabb452686968e48b67397da5f97445f5b">bool</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if slice is not empty. </p>

</div>
</div>
<a id="a8429d3d98004f500851f0a5f51559b2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8429d3d98004f500851f0a5f51559b2b">&#9670;&nbsp;</a></span>operator::std::basic_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , class T , class A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mdbx_8h_09_09.html#a006b5a41dcea1c018efaa0b36fb94cc5">MDBX_CXX20_CONSTEXPR</a> mdbx::slice::operator::std::basic_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3c2f0695e60542de8f55001ce0f80a5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c2f0695e60542de8f55001ce0f80a5b">&#9670;&nbsp;</a></span>operator::std::basic_string_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api__macros.html#ga4912ff2f7d4f6a15b96c54e5cf8ee0f5">MDBX_CXX11_CONSTEXPR</a> mdbx::slice::operator::std::basic_string_view </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a string_view that references the same data as this slice. </p>

</div>
</div>
<a id="a23f41ea724d8878c14f0b407655e46e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23f41ea724d8878c14f0b407655e46e3">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmdbx_1_1slice.html">slice</a> &amp; mdbx::slice::operator= </td>
          <td>(</td>
          <td class="paramtype">::<a class="el" href="group__c__api.html#ga5eedfc4a83296bbf0f8ff93359cb0900">MDBX_val</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3efbf9b9bc5394c17cf745b12061e8fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3efbf9b9bc5394c17cf745b12061e8fc">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmdbx_1_1slice.html">slice</a>&amp; mdbx::slice::operator= </td>
          <td>(</td>
          <td class="paramtype">::std::basic_string_view&lt; C, T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>view</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a59dfaa97f712df262357c1c5eef424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a59dfaa97f712df262357c1c5eef424">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmdbx_1_1slice.html">slice</a>&amp; mdbx::slice::operator= </td>
          <td>(</td>
          <td class="paramtype">const ::std::basic_string_view&lt; C, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>view</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7681c3ef3e4874dff08d4be4239e226e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7681c3ef3e4874dff08d4be4239e226e">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmdbx_1_1slice.html">slice</a>&amp; mdbx::slice::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5a81234bece30a8a472f7ca0ef4ebc88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a81234bece30a8a472f7ca0ef4ebc88">&#9670;&nbsp;</a></span>operator=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmdbx_1_1slice.html">slice</a> &amp; mdbx::slice::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a77b4684b8115062a6eeb332f08a0fecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77b4684b8115062a6eeb332f08a0fecc">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemdbx.html#acf30affbf4d2cbbaf4e41effd5196306">byte</a> mdbx::slice::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the nth byte in the referenced data. </p>
<dl class="section pre"><dt>Precondition</dt><dd>REQUIRES: <code>n &lt; <a class="el" href="structmdbx_1_1slice.html#a3f2b59fdcc601375fcf632c9fe131d25" title="Returns the number of bytes.">size()</a></code> </dd></dl>

</div>
</div>
<a id="a9cd0982cb9fa6eed01a48fc05c8c7ec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cd0982cb9fa6eed01a48fc05c8c7ec1">&#9670;&nbsp;</a></span>remove_prefix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mdbx::slice::remove_prefix </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drops the first "n" bytes from this slice. </p>
<dl class="section pre"><dt>Precondition</dt><dd>REQUIRES: <code>n &lt;= <a class="el" href="structmdbx_1_1slice.html#a3f2b59fdcc601375fcf632c9fe131d25" title="Returns the number of bytes.">size()</a></code> </dd></dl>

</div>
</div>
<a id="a1c89ebdb77acb3f278b50c680e8b7d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c89ebdb77acb3f278b50c680e8b7d07">&#9670;&nbsp;</a></span>remove_suffix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mdbx::slice::remove_suffix </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drops the last "n" bytes from this slice. </p>
<dl class="section pre"><dt>Precondition</dt><dd>REQUIRES: <code>n &lt;= <a class="el" href="structmdbx_1_1slice.html#a3f2b59fdcc601375fcf632c9fe131d25" title="Returns the number of bytes.">size()</a></code> </dd></dl>

</div>
</div>
<a id="a87d2f66875e4ffc47c76f577d32bff5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87d2f66875e4ffc47c76f577d32bff5d">&#9670;&nbsp;</a></span>safe_head()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmdbx_1_1slice.html">slice</a> mdbx::slice::safe_head </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first "n" bytes of the slice. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if <code>n &gt;= <a class="el" href="structmdbx_1_1slice.html#a3f2b59fdcc601375fcf632c9fe131d25" title="Returns the number of bytes.">size()</a></code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87248db88360ce8adfa4c6dd024006e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87248db88360ce8adfa4c6dd024006e8">&#9670;&nbsp;</a></span>safe_middle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmdbx_1_1slice.html">slice</a> mdbx::slice::safe_middle </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the middle "n" bytes of the slice. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if <code>from + n &gt;= <a class="el" href="structmdbx_1_1slice.html#a3f2b59fdcc601375fcf632c9fe131d25" title="Returns the number of bytes.">size()</a></code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6fbe96f44c47c47bb524a80e2172a2ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fbe96f44c47c47bb524a80e2172a2ee">&#9670;&nbsp;</a></span>safe_remove_prefix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mdbx::slice::safe_remove_prefix </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drops the first "n" bytes from this slice. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if <code>n &gt; <a class="el" href="structmdbx_1_1slice.html#a3f2b59fdcc601375fcf632c9fe131d25" title="Returns the number of bytes.">size()</a></code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a96f8c368da6326b7c1d7b639e75a14a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96f8c368da6326b7c1d7b639e75a14a6">&#9670;&nbsp;</a></span>safe_remove_suffix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mdbx::slice::safe_remove_suffix </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drops the last "n" bytes from this slice. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if <code>n &gt; <a class="el" href="structmdbx_1_1slice.html#a3f2b59fdcc601375fcf632c9fe131d25" title="Returns the number of bytes.">size()</a></code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a696ca1e1dc1bad744f5d132c49eb8847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a696ca1e1dc1bad744f5d132c49eb8847">&#9670;&nbsp;</a></span>safe_tail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmdbx_1_1slice.html">slice</a> mdbx::slice::safe_tail </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the last "n" bytes of the slice. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if <code>n &gt;= <a class="el" href="structmdbx_1_1slice.html#a3f2b59fdcc601375fcf632c9fe131d25" title="Returns the number of bytes.">size()</a></code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f2b59fdcc601375fcf632c9fe131d25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f2b59fdcc601375fcf632c9fe131d25">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api__macros.html#ga4912ff2f7d4f6a15b96c54e5cf8ee0f5">MDBX_CXX11_CONSTEXPR</a> size_t mdbx::slice::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of bytes. </p>

</div>
</div>
<a id="a91a146d36fac778170958a1cd2ab4437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91a146d36fac778170958a1cd2ab4437">&#9670;&nbsp;</a></span>starts_with()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api__macros.html#gabb452686968e48b67397da5f97445f5b">bool</a> mdbx::slice::starts_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;&#160;</td>
          <td class="paramname"><em>prefix</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the data starts with the given prefix. </p>

</div>
</div>
<a id="a955e242bd504dd31c7c6a00b76ffebec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a955e242bd504dd31c7c6a00b76ffebec">&#9670;&nbsp;</a></span>string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C  = char, class T  = ::std::char_traits&lt;C&gt;, class A  = legacy_allocator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mdbx_8h_09_09.html#a006b5a41dcea1c018efaa0b36fb94cc5">MDBX_CXX20_CONSTEXPR</a> ::std::basic_string&lt;C, T, A&gt; mdbx::slice::string </td>
          <td>(</td>
          <td class="paramtype">const A &amp;&#160;</td>
          <td class="paramname"><em>allocator</em> = <code>A()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a55710b770fc853bf6e83c3c6e279fa27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55710b770fc853bf6e83c3c6e279fa27">&#9670;&nbsp;</a></span>string_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C  = char, class T  = ::std::char_traits&lt;C&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api__macros.html#ga4912ff2f7d4f6a15b96c54e5cf8ee0f5">MDBX_CXX11_CONSTEXPR</a> ::std::basic_string_view&lt;C, T&gt; mdbx::slice::string_view </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a string_view that references the same data as this slice. </p>

</div>
</div>
<a id="a4cf561990846e991c8a30b57494edc82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cf561990846e991c8a30b57494edc82">&#9670;&nbsp;</a></span>swap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mdbx::slice::swap </td>
          <td>(</td>
          <td class="paramtype">::std::basic_string_view&lt; C, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>view</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a33c21b201a228386fbafbde3fedd04b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33c21b201a228386fbafbde3fedd04b3">&#9670;&nbsp;</a></span>swap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mdbx::slice::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa3abf94daa6077ebbf429187c2029086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3abf94daa6077ebbf429187c2029086">&#9670;&nbsp;</a></span>tail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmdbx_1_1slice.html">slice</a> mdbx::slice::tail </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the last "n" bytes of the slice. </p>
<dl class="section pre"><dt>Precondition</dt><dd>REQUIRES: <code>n &lt;= <a class="el" href="structmdbx_1_1slice.html#a3f2b59fdcc601375fcf632c9fe131d25" title="Returns the number of bytes.">size()</a></code> </dd></dl>

</div>
</div>
<a id="ad391e8c064914c01a0da51db61c3a131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad391e8c064914c01a0da51db61c3a131">&#9670;&nbsp;</a></span>to_base58()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mdbx::slice::to_base58 </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dest_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>wrap_width</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills the buffer by <a href="https://en.wikipedia.org/wiki/Base58">Base58</a> data dump of slice content. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if given buffer is too small. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a655678563a631f584727ea0a594f8a7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a655678563a631f584727ea0a594f8a7c">&#9670;&nbsp;</a></span>to_base58_bytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api__macros.html#ga4912ff2f7d4f6a15b96c54e5cf8ee0f5">MDBX_CXX11_CONSTEXPR</a> size_t mdbx::slice::to_base58_bytes </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>wrap_width</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the buffer size in bytes needed for <a href="https://en.wikipedia.org/wiki/Base58">Base58</a> data dump of slice content. </p>

</div>
</div>
<a id="a616911ad40a1ed299e75b292ab909419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a616911ad40a1ed299e75b292ab909419">&#9670;&nbsp;</a></span>to_base64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mdbx::slice::to_base64 </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dest_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>wrap_width</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills the buffer by <a href="https://en.wikipedia.org/wiki/Base64">Base64</a> data dump. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if given buffer is too small. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac29871ca22d6f38aac998e1294e70540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac29871ca22d6f38aac998e1294e70540">&#9670;&nbsp;</a></span>to_base64_bytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api__macros.html#ga4912ff2f7d4f6a15b96c54e5cf8ee0f5">MDBX_CXX11_CONSTEXPR</a> size_t mdbx::slice::to_base64_bytes </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>wrap_width</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the buffer size in bytes needed for <a href="https://en.wikipedia.org/wiki/Base64">Base64</a> data dump. </p>

</div>
</div>
<a id="a575904c24d83e8f4b3c49ed17330bcce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a575904c24d83e8f4b3c49ed17330bcce">&#9670;&nbsp;</a></span>to_hex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mdbx::slice::to_hex </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dest_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__api__macros.html#gabb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>uppercase</em> = <code><a class="el" href="group__api__macros.html#ga65e9886d74aaee76545e83dd09011727">false</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>wrap_width</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills the buffer by hexadecimal data dump of slice content. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>if given buffer is too small. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f04bb7b2fb39854fa785c5b5eb6b415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f04bb7b2fb39854fa785c5b5eb6b415">&#9670;&nbsp;</a></span>to_hex_bytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api__macros.html#ga4912ff2f7d4f6a15b96c54e5cf8ee0f5">MDBX_CXX11_CONSTEXPR</a> size_t mdbx::slice::to_hex_bytes </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>wrap_width</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the buffer size in bytes needed for hexadecimal data dump of slice content. </p>

</div>
</div>
<a id="a46de2d2ffccf2b5f153b9d2d74120e45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46de2d2ffccf2b5f153b9d2d74120e45">&#9670;&nbsp;</a></span>wrap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__api__macros.html#gad12bcc78029f8edc91982e1bac29eeb9">MDBX_CXX14_CONSTEXPR</a> <a class="el" href="structmdbx_1_1slice.html">slice</a> mdbx::slice::wrap </td>
          <td>(</td>
          <td class="paramtype">const char(&amp;)&#160;</td>
          <td class="paramname"><em>text</em>[SIZE]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af3356e3700bd7172c939060241d3a991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3356e3700bd7172c939060241d3a991">&#9670;&nbsp;</a></span>wrap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename POD &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__api__macros.html#gad12bcc78029f8edc91982e1bac29eeb9">MDBX_CXX14_CONSTEXPR</a> <a class="el" href="structmdbx_1_1slice.html">slice</a> mdbx::slice::wrap </td>
          <td>(</td>
          <td class="paramtype">const POD &amp;&#160;</td>
          <td class="paramname"><em>pod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="aaa7e1c7159660896d5573d92dd57c5ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa7e1c7159660896d5573d92dd57c5ca">&#9670;&nbsp;</a></span>operator!=</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api__macros.html#gabb452686968e48b67397da5f97445f5b">bool</a> operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adb7349d8724735c67f5bf06550c8f1fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb7349d8724735c67f5bf06550c8f1fe">&#9670;&nbsp;</a></span>operator&lt;</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api__macros.html#gabb452686968e48b67397da5f97445f5b">bool</a> operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2071047a9332799185ac96798730ed4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2071047a9332799185ac96798730ed4a">&#9670;&nbsp;</a></span>operator&lt;=</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api__macros.html#gabb452686968e48b67397da5f97445f5b">bool</a> operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa11b3c7589162ca7be1a433924adc77b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa11b3c7589162ca7be1a433924adc77b">&#9670;&nbsp;</a></span>operator==</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api__macros.html#gabb452686968e48b67397da5f97445f5b">bool</a> operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0a038605fe8f60588b31f7872b1411c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a038605fe8f60588b31f7872b1411c9">&#9670;&nbsp;</a></span>operator&gt;</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api__macros.html#gabb452686968e48b67397da5f97445f5b">bool</a> operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3876d218971e4e5ea14092c070638d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3876d218971e4e5ea14092c070638d7b">&#9670;&nbsp;</a></span>operator&gt;=</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__api__macros.html#gabb452686968e48b67397da5f97445f5b">bool</a> operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmdbx_1_1slice.html">slice</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="mdbx_8h_09_09_source.html">mdbx.h++</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacemdbx.html">mdbx</a></li><li class="navelem"><a class="el" href="structmdbx_1_1slice.html">slice</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
